CBackend: iterating function 1759: llvm.dbg.declare
CBackend: iterating function 1759: llvm.nvvm.read.ptx.sreg.tid.x
CBackend: iterating function 1759: cudaSetupArgument
CBackend: iterating function 1759: cudaLaunch
CBackend: iterating function 1759: main
CBackend: printing function 1770main
CBackend: here? 1175
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
term 6818:   br i1 %exitcond, label %for.body21, label %for.end34, !dbg !1073
none omp loop ub: i64 10
CBackend: here? 1175
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
term 6818:   br i1 %exitcond7, label %header.1.preheader, label %kcall.end, !tulip.doall.loop.grid !1058
none omp loop ub:   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
CBackend: here? 1175
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
term 6818:   br i1 %exitcond10, label %for.body, label %for.end, !dbg !1028
none omp loop ub: i64 10
CBackend: here? 1175
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
term 6818:   br i1 %exitcond6, label %kcall.configok, label %latch.0, !tulip.doall.loop.block !1058
none omp loop ub: i32 256
=========LOOP PROFILES=========
Loop: Loop at depth 1 containing: %for.cond19<header><exiting>,%for.body21,%for.inc32<latch>

isomp: 0
Loop: Loop at depth 1 containing: %header.0<header><exiting>,%header.1.preheader,%header.1,%latch.0<latch>,%kcall.configok,%latch.1
    Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

isomp: 0
Loop: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.inc<latch>

isomp: 0
Loop: Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

isomp: 0
SUSAN: opnd0  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: opnd1i64 10
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: opnd0  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: opnd1  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: opnd0  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: opnd1i32 256
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: opnd0  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: opnd1i64 10
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: BB:
entry:
  %d_a = alloca float*, align 8
  %d_b = alloca float*, align 8
  %d_c = alloca float*, align 8
  %agg.tmp = alloca %struct.dim3, align 4
  %agg.tmp12 = alloca %struct.dim3, align 4
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  %agg.tmp12.coerce = alloca { i64, i32 }, align 4
  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
  %0 = bitcast i8* %call to float*, !dbg !1014
  call void @llvm.dbg.value(metadata float* %0, metadata !1015, metadata !DIExpression()), !dbg !1016
  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
  %1 = bitcast i8* %call1 to float*, !dbg !1018
  call void @llvm.dbg.value(metadata float* %1, metadata !1019, metadata !DIExpression()), !dbg !1016
  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
  call void @llvm.dbg.value(metadata float* %4, metadata !1021, metadata !DIExpression()), !dbg !1016
  call void @llvm.dbg.value(metadata i32 0, metadata !1022, metadata !DIExpression()), !dbg !1024
  br label %for.cond, !dbg !1025

SUSAN: BB:
for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
  call void @llvm.dbg.value(metadata i64 %indvars.iv8, metadata !1022, metadata !DIExpression()), !dbg !1024
  %exitcond10 = icmp ne i64 %indvars.iv8, 10, !dbg !1026
  br i1 %exitcond10, label %for.body, label %for.end, !dbg !1028

SUSAN: BB:
for.body:                                         ; preds = %for.cond
  %2 = trunc i64 %indvars.iv8 to i32, !dbg !1029
  %conv = sitofp i32 %2 to float, !dbg !1029
  %arrayidx = getelementptr inbounds float, float* %0, i64 %indvars.iv8, !dbg !1031
  store float %conv, float* %arrayidx, align 4, !dbg !1032
  %3 = trunc i64 %indvars.iv8 to i32, !dbg !1033
  %conv3 = sitofp i32 %3 to float, !dbg !1033
  %mul = fmul contract float %conv3, 2.000000e+00, !dbg !1034
  %arrayidx5 = getelementptr inbounds float, float* %1, i64 %indvars.iv8, !dbg !1035
  store float %mul, float* %arrayidx5, align 4, !dbg !1036
  br label %for.inc, !dbg !1037

SUSAN: BB:
for.inc:                                          ; preds = %for.body
  %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1, !dbg !1038
  call void @llvm.dbg.value(metadata i32 undef, metadata !1022, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !1024
  br label %for.cond, !dbg !1039, !llvm.loop !1040

SUSAN: BB:
for.end:                                          ; preds = %for.cond
  %4 = bitcast i8* %call2 to float*, !dbg !1042
  call void @llvm.dbg.declare(metadata float** %d_a, metadata !1043, metadata !DIExpression()), !dbg !1044
  call void @llvm.dbg.declare(metadata float** %d_b, metadata !1045, metadata !DIExpression()), !dbg !1046
  call void @llvm.dbg.declare(metadata float** %d_c, metadata !1047, metadata !DIExpression()), !dbg !1048
  %5 = bitcast float** %d_a to i8**, !dbg !1049
  %call6 = call i32 @cudaMalloc(i8** %5, i64 40), !dbg !1050
  %6 = bitcast float** %d_b to i8**, !dbg !1051
  %call7 = call i32 @cudaMalloc(i8** %6, i64 40), !dbg !1052
  %7 = bitcast float** %d_c to i8**, !dbg !1053
  %call8 = call i32 @cudaMalloc(i8** %7, i64 40), !dbg !1054
  %8 = bitcast float* %0 to i8*, !dbg !1055
  %9 = bitcast float* %0 to i8*, !dbg !1056
  %call9 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 40, i32 1), !dbg !1057, !tulip.target.start.of.map !1058
  call void @llvm.dbg.value(metadata i32 256, metadata !1059, metadata !DIExpression()), !dbg !1016
  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
  call void @llvm.dbg.value(metadata i32 %call11, metadata !1062, metadata !DIExpression()), !dbg !1016
  %dim3gep.0 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 0
  store i32 %call11, i32* %dim3gep.0
  %dim3gep.1 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 1
  store i32 1, i32* %dim3gep.1
  %dim3gep.2 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 2
  store i32 1, i32* %dim3gep.2
  %dim3gep.02 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 0
  store i32 256, i32* %dim3gep.02
  %dim3gep.13 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 1
  store i32 1, i32* %dim3gep.13
  %dim3gep.24 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 2
  store i32 1, i32* %dim3gep.24
  %10 = bitcast { i64, i32 }* %agg.tmp.coerce to i8*, !dbg !1063
  %11 = bitcast %struct.dim3* %agg.tmp to i8*, !dbg !1063
  %12 = call i8* @memcpy(i8* %10, i8* %11, i64 12), !dbg !1063
  %13 = bitcast { i64, i32 }* %agg.tmp12.coerce to i8*, !dbg !1063
  %14 = bitcast %struct.dim3* %agg.tmp12 to i8*, !dbg !1063
  %15 = call i8* @memcpy(i8* %13, i8* %14, i64 12), !dbg !1063
  br label %header.0

SUSAN: BB:
header.0:                                         ; preds = %latch.0, %for.end
  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
  %exitcond7 = icmp ne i32 %indvar.0, %call11
  br i1 %exitcond7, label %header.1.preheader, label %kcall.end, !tulip.doall.loop.grid !1058

SUSAN: BB:
header.1.preheader:                               ; preds = %header.0
  br label %header.1

SUSAN: BB:
header.1:                                         ; preds = %header.1.preheader, %latch.1
  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
  %exitcond6 = icmp ne i32 %indvar.1, 256
  br i1 %exitcond6, label %kcall.configok, label %latch.0, !tulip.doall.loop.block !1058

SUSAN: BB:
latch.1:                                          ; preds = %kcall.configok
  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
  br label %header.1

SUSAN: BB:
latch.0:                                          ; preds = %header.1
  %indvar.next.0 = add i32 %indvar.0, 1
  br label %header.0

SUSAN: BB:
kcall.configok:                                   ; preds = %header.1
  call void @_Z10vector_addPfS_S_i.1(float* %0, float* %1, float* %4, i32 10, i32 %call11, i32 1, i32 1, i32 256, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
  br label %latch.1

SUSAN: BB:
kcall.end:                                        ; preds = %header.0
  %16 = bitcast float* %4 to i8*, !dbg !1064
  %17 = bitcast float* %4 to i8*, !dbg !1065
  %call14 = call i32 @cudaMemcpy(i8* %16, i8* %17, i64 40, i32 2), !dbg !1066, !tulip.target.end.of.map !1058
  call void @llvm.dbg.value(metadata i32 0, metadata !1067, metadata !DIExpression()), !dbg !1069
  br label %for.cond19, !dbg !1070

SUSAN: BB:
for.cond19:                                       ; preds = %for.inc32, %kcall.end
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !1067, metadata !DIExpression()), !dbg !1069
  %exitcond = icmp ne i64 %indvars.iv, 10, !dbg !1071
  br i1 %exitcond, label %for.body21, label %for.end34, !dbg !1073

SUSAN: BB:
for.body21:                                       ; preds = %for.cond19
  %arrayidx23 = getelementptr inbounds float, float* %0, i64 %indvars.iv, !dbg !1074
  %18 = load float, float* %arrayidx23, align 4, !dbg !1074
  %conv24 = fpext float %18 to double, !dbg !1074
  %arrayidx26 = getelementptr inbounds float, float* %1, i64 %indvars.iv, !dbg !1076
  %19 = load float, float* %arrayidx26, align 4, !dbg !1076
  %conv27 = fpext float %19 to double, !dbg !1076
  %arrayidx29 = getelementptr inbounds float, float* %4, i64 %indvars.iv, !dbg !1077
  %20 = load float, float* %arrayidx29, align 4, !dbg !1077
  %conv30 = fpext float %20 to double, !dbg !1077
  %call31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i64 0, i64 0), double %conv24, double %conv27, double %conv30), !dbg !1078
  br label %for.inc32, !dbg !1079

SUSAN: BB:
for.inc32:                                        ; preds = %for.body21
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1080
  call void @llvm.dbg.value(metadata i32 undef, metadata !1067, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !1069
  br label %for.cond19, !dbg !1081, !llvm.loop !1082

SUSAN: BB:
for.end34:                                        ; preds = %for.cond19
  %21 = bitcast float* %0 to i8*, !dbg !1084
  call void @free(i8* %21) #8, !dbg !1085
  %22 = bitcast float* %1 to i8*, !dbg !1086
  call void @free(i8* %22) #8, !dbg !1087
  %23 = bitcast float* %4 to i8*, !dbg !1088
  call void @free(i8* %23) #8, !dbg !1089
  ret i32 0, !dbg !1090

SUSAN: trying to get exit for loop: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.inc<latch>

SUSAN exitBB: 
for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
  call void @llvm.dbg.value(metadata i64 %indvars.iv8, metadata !1022, metadata !DIExpression()), !dbg !1024
  %exitcond10 = icmp ne i64 %indvars.iv8, 10, !dbg !1026
  br i1 %exitcond10, label %for.body, label %for.end, !dbg !1028

SUSAN: trying to get exit for loop: Loop at depth 1 containing: %header.0<header><exiting>,%header.1.preheader,%header.1,%latch.0<latch>,%kcall.configok,%latch.1
    Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

SUSAN exitBB: 
header.0:                                         ; preds = %latch.0, %for.end
  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
  %exitcond7 = icmp ne i32 %indvar.0, %call11
  br i1 %exitcond7, label %header.1.preheader, label %kcall.end, !tulip.doall.loop.grid !1058

SUSAN: trying to get exit for loop: Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

SUSAN exitBB: 
header.1:                                         ; preds = %header.1.preheader, %latch.1
  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
  %exitcond6 = icmp ne i32 %indvar.1, 256
  br i1 %exitcond6, label %kcall.configok, label %latch.0, !tulip.doall.loop.block !1058

SUSAN: trying to get exit for loop: Loop at depth 1 containing: %for.cond19<header><exiting>,%for.body21,%for.inc32<latch>

SUSAN exitBB: 
for.cond19:                                       ; preds = %for.inc32, %kcall.end
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !1067, metadata !DIExpression()), !dbg !1069
  %exitcond = icmp ne i64 %indvars.iv, 10, !dbg !1071
  br i1 %exitcond, label %for.body21, label %for.end34, !dbg !1073

SUSAN: entry block is a linear region! entry
CBERegion: including entry in a linear region
CBERegion: nextBB 
entry:
  %d_a = alloca float*, align 8
  %d_b = alloca float*, align 8
  %d_c = alloca float*, align 8
  %agg.tmp = alloca %struct.dim3, align 4
  %agg.tmp12 = alloca %struct.dim3, align 4
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  %agg.tmp12.coerce = alloca { i64, i32 }, align 4
  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
  %0 = bitcast i8* %call to float*, !dbg !1014
  call void @llvm.dbg.value(metadata float* %0, metadata !1015, metadata !DIExpression()), !dbg !1016
  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
  %1 = bitcast i8* %call1 to float*, !dbg !1018
  call void @llvm.dbg.value(metadata float* %1, metadata !1019, metadata !DIExpression()), !dbg !1016
  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
  call void @llvm.dbg.value(metadata float* %4, metadata !1021, metadata !DIExpression()), !dbg !1016
  call void @llvm.dbg.value(metadata i32 0, metadata !1022, metadata !DIExpression()), !dbg !1024
  br label %for.cond, !dbg !1025

SUSAN: nextRegionEntryBB for.cond
CBackend: entryBB is a loop: for.cond
SUSAN: entry block is a loop region! for.cond
creating loop region for entryBB: for.cond
SUSAN: loop at 355 Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.inc<latch>

SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
term 6818:   br i1 %exitcond10, label %for.body, label %for.end, !dbg !1028
CBERegion: startBB 393: 
for.body:                                         ; preds = %for.cond
  %2 = trunc i64 %indvars.iv8 to i32, !dbg !1029
  %conv = sitofp i32 %2 to float, !dbg !1029
  %arrayidx = getelementptr inbounds float, float* %0, i64 %indvars.iv8, !dbg !1031
  store float %conv, float* %arrayidx, align 4, !dbg !1032
  %3 = trunc i64 %indvars.iv8 to i32, !dbg !1033
  %conv3 = sitofp i32 %3 to float, !dbg !1033
  %mul = fmul contract float %conv3, 2.000000e+00, !dbg !1034
  %arrayidx5 = getelementptr inbounds float, float* %1, i64 %indvars.iv8, !dbg !1035
  store float %mul, float* %arrayidx5, align 4, !dbg !1036
  br label %for.inc, !dbg !1037

CBERegion: here? 149
CBackend: entryBB is a loop: for.body
but not a header!
SUSAN: entry block is a linear region! for.body
CBERegion: including for.body in a linear region
CBERegion: nextBB 
for.body:                                         ; preds = %for.cond
  %2 = trunc i64 %indvars.iv8 to i32, !dbg !1029
  %conv = sitofp i32 %2 to float, !dbg !1029
  %arrayidx = getelementptr inbounds float, float* %0, i64 %indvars.iv8, !dbg !1031
  store float %conv, float* %arrayidx, align 4, !dbg !1032
  %3 = trunc i64 %indvars.iv8 to i32, !dbg !1033
  %conv3 = sitofp i32 %3 to float, !dbg !1033
  %mul = fmul contract float %conv3, 2.000000e+00, !dbg !1034
  %arrayidx5 = getelementptr inbounds float, float* %1, i64 %indvars.iv8, !dbg !1035
  store float %mul, float* %arrayidx5, align 4, !dbg !1036
  br label %for.inc, !dbg !1037

SUSAN: nextRegionEntryBB for.inc
for region: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.inc<latch>

SUSAN: nextRegionEntryBB for.end
SUSAN: entry block is a linear region! for.end
CBERegion: including for.end in a linear region
CBERegion: nextBB 
for.end:                                          ; preds = %for.cond
  %4 = bitcast i8* %call2 to float*, !dbg !1042
  call void @llvm.dbg.declare(metadata float** %d_a, metadata !1043, metadata !DIExpression()), !dbg !1044
  call void @llvm.dbg.declare(metadata float** %d_b, metadata !1045, metadata !DIExpression()), !dbg !1046
  call void @llvm.dbg.declare(metadata float** %d_c, metadata !1047, metadata !DIExpression()), !dbg !1048
  %5 = bitcast float** %d_a to i8**, !dbg !1049
  %call6 = call i32 @cudaMalloc(i8** %5, i64 40), !dbg !1050
  %6 = bitcast float** %d_b to i8**, !dbg !1051
  %call7 = call i32 @cudaMalloc(i8** %6, i64 40), !dbg !1052
  %7 = bitcast float** %d_c to i8**, !dbg !1053
  %call8 = call i32 @cudaMalloc(i8** %7, i64 40), !dbg !1054
  %8 = bitcast float* %0 to i8*, !dbg !1055
  %9 = bitcast float* %0 to i8*, !dbg !1056
  %call9 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 40, i32 1), !dbg !1057, !tulip.target.start.of.map !1058
  call void @llvm.dbg.value(metadata i32 256, metadata !1059, metadata !DIExpression()), !dbg !1016
  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
  call void @llvm.dbg.value(metadata i32 %call11, metadata !1062, metadata !DIExpression()), !dbg !1016
  %dim3gep.0 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 0
  store i32 %call11, i32* %dim3gep.0
  %dim3gep.1 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 1
  store i32 1, i32* %dim3gep.1
  %dim3gep.2 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 2
  store i32 1, i32* %dim3gep.2
  %dim3gep.02 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 0
  store i32 256, i32* %dim3gep.02
  %dim3gep.13 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 1
  store i32 1, i32* %dim3gep.13
  %dim3gep.24 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 2
  store i32 1, i32* %dim3gep.24
  %10 = bitcast { i64, i32 }* %agg.tmp.coerce to i8*, !dbg !1063
  %11 = bitcast %struct.dim3* %agg.tmp to i8*, !dbg !1063
  %12 = call i8* @memcpy(i8* %10, i8* %11, i64 12), !dbg !1063
  %13 = bitcast { i64, i32 }* %agg.tmp12.coerce to i8*, !dbg !1063
  %14 = bitcast %struct.dim3* %agg.tmp12 to i8*, !dbg !1063
  %15 = call i8* @memcpy(i8* %13, i8* %14, i64 12), !dbg !1063
  br label %header.0

SUSAN: nextRegionEntryBB header.0
CBackend: entryBB is a loop: header.0
SUSAN: entry block is a loop region! header.0
creating loop region for entryBB: header.0
SUSAN: loop at 355 Loop at depth 1 containing: %header.0<header><exiting>,%header.1.preheader,%header.1,%latch.0<latch>,%kcall.configok,%latch.1
    Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
term 6818:   br i1 %exitcond7, label %header.1.preheader, label %kcall.end, !tulip.doall.loop.grid !1058
CBERegion: startBB 393: 
header.1.preheader:                               ; preds = %header.0
  br label %header.1

CBERegion: here? 149
CBackend: entryBB is a loop: header.1.preheader
but not a header!
SUSAN: entry block is a linear region! header.1.preheader
CBERegion: including header.1.preheader in a linear region
CBERegion: nextBB 
header.1.preheader:                               ; preds = %header.0
  br label %header.1

SUSAN: nextRegionEntryBB header.1
for region: Loop at depth 1 containing: %header.0<header><exiting>,%header.1.preheader,%header.1,%latch.0<latch>,%kcall.configok,%latch.1
    Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

CBERegion: here? 149
CBackend: entryBB is a loop: header.1
SUSAN: entry block is a loop region! header.1
creating loop region for entryBB: header.1
SUSAN: loop at 355 Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
term 6818:   br i1 %exitcond6, label %kcall.configok, label %latch.0, !tulip.doall.loop.block !1058
CBERegion: startBB 393: 
kcall.configok:                                   ; preds = %header.1
  call void @_Z10vector_addPfS_S_i.1(float* %0, float* %1, float* %4, i32 10, i32 %call11, i32 1, i32 1, i32 256, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
  br label %latch.1

CBERegion: here? 149
CBackend: entryBB is a loop: kcall.configok
but not a header!
SUSAN: entry block is a linear region! kcall.configok
CBERegion: including kcall.configok in a linear region
CBERegion: nextBB 
kcall.configok:                                   ; preds = %header.1
  call void @_Z10vector_addPfS_S_i.1(float* %0, float* %1, float* %4, i32 10, i32 %call11, i32 1, i32 1, i32 256, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
  br label %latch.1

SUSAN: nextRegionEntryBB latch.1
for region: Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

SUSAN: nextRegionEntryBB latch.0
for region: Loop at depth 1 containing: %header.0<header><exiting>,%header.1.preheader,%header.1,%latch.0<latch>,%kcall.configok,%latch.1
    Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

SUSAN: nextRegionEntryBB kcall.end
SUSAN: entry block is a linear region! kcall.end
CBERegion: including kcall.end in a linear region
CBERegion: nextBB 
kcall.end:                                        ; preds = %header.0
  %16 = bitcast float* %4 to i8*, !dbg !1064
  %17 = bitcast float* %4 to i8*, !dbg !1065
  %call14 = call i32 @cudaMemcpy(i8* %16, i8* %17, i64 40, i32 2), !dbg !1066, !tulip.target.end.of.map !1058
  call void @llvm.dbg.value(metadata i32 0, metadata !1067, metadata !DIExpression()), !dbg !1069
  br label %for.cond19, !dbg !1070

SUSAN: nextRegionEntryBB for.cond19
CBackend: entryBB is a loop: for.cond19
SUSAN: entry block is a loop region! for.cond19
creating loop region for entryBB: for.cond19
SUSAN: loop at 355 Loop at depth 1 containing: %for.cond19<header><exiting>,%for.body21,%for.inc32<latch>

SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
term 6818:   br i1 %exitcond, label %for.body21, label %for.end34, !dbg !1073
CBERegion: startBB 393: 
for.body21:                                       ; preds = %for.cond19
  %arrayidx23 = getelementptr inbounds float, float* %0, i64 %indvars.iv, !dbg !1074
  %18 = load float, float* %arrayidx23, align 4, !dbg !1074
  %conv24 = fpext float %18 to double, !dbg !1074
  %arrayidx26 = getelementptr inbounds float, float* %1, i64 %indvars.iv, !dbg !1076
  %19 = load float, float* %arrayidx26, align 4, !dbg !1076
  %conv27 = fpext float %19 to double, !dbg !1076
  %arrayidx29 = getelementptr inbounds float, float* %4, i64 %indvars.iv, !dbg !1077
  %20 = load float, float* %arrayidx29, align 4, !dbg !1077
  %conv30 = fpext float %20 to double, !dbg !1077
  %call31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i64 0, i64 0), double %conv24, double %conv27, double %conv30), !dbg !1078
  br label %for.inc32, !dbg !1079

CBERegion: here? 149
CBackend: entryBB is a loop: for.body21
but not a header!
SUSAN: entry block is a linear region! for.body21
CBERegion: including for.body21 in a linear region
CBERegion: nextBB 
for.body21:                                       ; preds = %for.cond19
  %arrayidx23 = getelementptr inbounds float, float* %0, i64 %indvars.iv, !dbg !1074
  %18 = load float, float* %arrayidx23, align 4, !dbg !1074
  %conv24 = fpext float %18 to double, !dbg !1074
  %arrayidx26 = getelementptr inbounds float, float* %1, i64 %indvars.iv, !dbg !1076
  %19 = load float, float* %arrayidx26, align 4, !dbg !1076
  %conv27 = fpext float %19 to double, !dbg !1076
  %arrayidx29 = getelementptr inbounds float, float* %4, i64 %indvars.iv, !dbg !1077
  %20 = load float, float* %arrayidx29, align 4, !dbg !1077
  %conv30 = fpext float %20 to double, !dbg !1077
  %call31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i64 0, i64 0), double %conv24, double %conv27, double %conv30), !dbg !1078
  br label %for.inc32, !dbg !1079

SUSAN: nextRegionEntryBB for.inc32
for region: Loop at depth 1 containing: %for.cond19<header><exiting>,%for.body21,%for.inc32<latch>

SUSAN: nextRegionEntryBB for.end34
SUSAN: entry block is a linear region! for.end34
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
global: @.str = private unnamed_addr constant [20 x i8] c"%.1f + %.1f = %.1f\0A\00", align 1
type: [20 x i8]
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: CI at 1400:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
SUSAN: found malloc 1403:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata float* %0, metadata !1015, metadata !DIExpression()), !dbg !1016
SUSAN: CI at 1400:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
SUSAN: found malloc 1403:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata float* %1, metadata !1019, metadata !DIExpression()), !dbg !1016
SUSAN: CI at 1400:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
SUSAN: found malloc 1403:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata float* %4, metadata !1021, metadata !DIExpression()), !dbg !1016
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 0, metadata !1022, metadata !DIExpression()), !dbg !1024
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i64 %indvars.iv8, metadata !1022, metadata !DIExpression()), !dbg !1024
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 undef, metadata !1022, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !1024
SUSAN: CI at 1400:   call void @llvm.dbg.declare(metadata float** %d_a, metadata !1043, metadata !DIExpression()), !dbg !1044
SUSAN: CI at 1400:   call void @llvm.dbg.declare(metadata float** %d_b, metadata !1045, metadata !DIExpression()), !dbg !1046
SUSAN: CI at 1400:   call void @llvm.dbg.declare(metadata float** %d_c, metadata !1047, metadata !DIExpression()), !dbg !1048
SUSAN: CI at 1400:   %call6 = call i32 @cudaMalloc(i8** %5, i64 40), !dbg !1050
SUSAN: CI at 1400:   %call7 = call i32 @cudaMalloc(i8** %6, i64 40), !dbg !1052
SUSAN: CI at 1400:   %call8 = call i32 @cudaMalloc(i8** %7, i64 40), !dbg !1054
SUSAN: CI at 1400:   %call9 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 40, i32 1), !dbg !1057, !tulip.target.start.of.map !1058
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 256, metadata !1059, metadata !DIExpression()), !dbg !1016
SUSAN: CI at 1400:   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 %call11, metadata !1062, metadata !DIExpression()), !dbg !1016
SUSAN: CI at 1400:   %12 = call i8* @memcpy(i8* %10, i8* %11, i64 12), !dbg !1063
SUSAN: CI at 1400:   %15 = call i8* @memcpy(i8* %13, i8* %14, i64 12), !dbg !1063
SUSAN: CI at 1400:   call void @_Z10vector_addPfS_S_i.1(float* %0, float* %1, float* %4, i32 10, i32 %call11, i32 1, i32 1, i32 256, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
SUSAN: CI at 1400:   %call14 = call i32 @cudaMemcpy(i8* %16, i8* %17, i64 40, i32 2), !dbg !1066, !tulip.target.end.of.map !1058
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 0, metadata !1067, metadata !DIExpression()), !dbg !1069
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !1067, metadata !DIExpression()), !dbg !1069
SUSAN: CI at 1400:   %call31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i64 0, i64 0), double %conv24, double %conv27, double %conv30), !dbg !1078
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 undef, metadata !1067, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !1069
SUSAN: CI at 1400:   call void @free(i8* %21) #8, !dbg !1085
SUSAN: CI at 1400:   call void @free(i8* %22) #8, !dbg !1087
SUSAN: CI at 1400:   call void @free(i8* %23) #8, !dbg !1089
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
========== IV MAP==========
SUSAN: found LP for L:Loop at depth 1 containing: %for.cond19<header><exiting>,%for.body21,%for.inc32<latch>

SUSAN: found LP for L:Loop at depth 1 containing: %header.0<header><exiting>,%header.1.preheader,%header.1,%latch.0<latch>,%kcall.configok,%latch.1
    Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

SUSAN: found LP for L:Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.inc<latch>

SUSAN: found LP for L:Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

currInst :  %0 = bitcast i8* %call to float*, !dbg !1014
currInst :  %arrayidx = getelementptr inbounds float, float* %0, i64 %indvars.iv8, !dbg !1031
currInst :  %9 = bitcast float* %0 to i8*, !dbg !1056
currInst :  %arrayidx23 = getelementptr inbounds float, float* %0, i64 %indvars.iv, !dbg !1074
currInst :  %21 = bitcast float* %0 to i8*, !dbg !1084
currInst :  %8 = bitcast float* %0 to i8*, !dbg !1055
currInst :  call void @_Z10vector_addPfS_S_i.1(float* %0, float* %1, float* %4, i32 10, i32 %call11, i32 1, i32 1, i32 256, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
currInst :  %1 = bitcast i8* %call1 to float*, !dbg !1018
currInst :  %arrayidx5 = getelementptr inbounds float, float* %1, i64 %indvars.iv8, !dbg !1035
currInst :  %arrayidx26 = getelementptr inbounds float, float* %1, i64 %indvars.iv, !dbg !1076
currInst :  %22 = bitcast float* %1 to i8*, !dbg !1086
currInst :  call void @_Z10vector_addPfS_S_i.1(float* %0, float* %1, float* %4, i32 10, i32 %call11, i32 1, i32 1, i32 256, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
currInst :  %exitcond10 = icmp ne i64 %indvars.iv8, 10, !dbg !1026
currInst :  br i1 %exitcond10, label %for.body, label %for.end, !dbg !1028
currInst :  %2 = trunc i64 %indvars.iv8 to i32, !dbg !1029
currInst :  %conv = sitofp i32 %2 to float, !dbg !1029
currInst :  store float %conv, float* %arrayidx, align 4, !dbg !1032
currInst :  %conv = sitofp i32 %2 to float, !dbg !1029
currInst :  store float %conv, float* %arrayidx, align 4, !dbg !1032
currInst :  %arrayidx = getelementptr inbounds float, float* %0, i64 %indvars.iv8, !dbg !1031
currInst :  store float %conv, float* %arrayidx, align 4, !dbg !1032
currInst :  %3 = trunc i64 %indvars.iv8 to i32, !dbg !1033
currInst :  %conv3 = sitofp i32 %3 to float, !dbg !1033
currInst :  %mul = fmul contract float %conv3, 2.000000e+00, !dbg !1034
currInst :  store float %mul, float* %arrayidx5, align 4, !dbg !1036
currInst :  %conv3 = sitofp i32 %3 to float, !dbg !1033
currInst :  %mul = fmul contract float %conv3, 2.000000e+00, !dbg !1034
currInst :  store float %mul, float* %arrayidx5, align 4, !dbg !1036
currInst :  %mul = fmul contract float %conv3, 2.000000e+00, !dbg !1034
currInst :  store float %mul, float* %arrayidx5, align 4, !dbg !1036
currInst :  %arrayidx5 = getelementptr inbounds float, float* %1, i64 %indvars.iv8, !dbg !1035
currInst :  store float %mul, float* %arrayidx5, align 4, !dbg !1036
currInst :  %4 = bitcast i8* %call2 to float*, !dbg !1042
currInst :  %16 = bitcast float* %4 to i8*, !dbg !1064
currInst :  %arrayidx29 = getelementptr inbounds float, float* %4, i64 %indvars.iv, !dbg !1077
currInst :  %23 = bitcast float* %4 to i8*, !dbg !1088
currInst :  %17 = bitcast float* %4 to i8*, !dbg !1065
currInst :  call void @_Z10vector_addPfS_S_i.1(float* %0, float* %1, float* %4, i32 10, i32 %call11, i32 1, i32 1, i32 256, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
currInst :  %5 = bitcast float** %d_a to i8**, !dbg !1049
currInst :  %call6 = call i32 @cudaMalloc(i8** %5, i64 40), !dbg !1050
currInst :  %6 = bitcast float** %d_b to i8**, !dbg !1051
currInst :  %call7 = call i32 @cudaMalloc(i8** %6, i64 40), !dbg !1052
currInst :  %7 = bitcast float** %d_c to i8**, !dbg !1053
currInst :  %call8 = call i32 @cudaMalloc(i8** %7, i64 40), !dbg !1054
currInst :  %8 = bitcast float* %0 to i8*, !dbg !1055
currInst :  %call9 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 40, i32 1), !dbg !1057, !tulip.target.start.of.map !1058
currInst :  %9 = bitcast float* %0 to i8*, !dbg !1056
currInst :  %call9 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 40, i32 1), !dbg !1057, !tulip.target.start.of.map !1058
currInst :  %dim3gep.0 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 0
currInst :  store i32 %call11, i32* %dim3gep.0
currInst :  %dim3gep.1 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 1
currInst :  store i32 1, i32* %dim3gep.1
currInst :  %dim3gep.2 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 2
currInst :  store i32 1, i32* %dim3gep.2
currInst :  %dim3gep.02 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 0
currInst :  store i32 256, i32* %dim3gep.02
currInst :  %dim3gep.13 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 1
currInst :  store i32 1, i32* %dim3gep.13
currInst :  %dim3gep.24 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 2
currInst :  store i32 1, i32* %dim3gep.24
currInst :  %10 = bitcast { i64, i32 }* %agg.tmp.coerce to i8*, !dbg !1063
currInst :  %12 = call i8* @memcpy(i8* %10, i8* %11, i64 12), !dbg !1063
currInst :  %11 = bitcast %struct.dim3* %agg.tmp to i8*, !dbg !1063
currInst :  %12 = call i8* @memcpy(i8* %10, i8* %11, i64 12), !dbg !1063
currInst :  %13 = bitcast { i64, i32 }* %agg.tmp12.coerce to i8*, !dbg !1063
currInst :  %15 = call i8* @memcpy(i8* %13, i8* %14, i64 12), !dbg !1063
currInst :  %14 = bitcast %struct.dim3* %agg.tmp12 to i8*, !dbg !1063
currInst :  %15 = call i8* @memcpy(i8* %13, i8* %14, i64 12), !dbg !1063
currInst :  %exitcond7 = icmp ne i32 %indvar.0, %call11
currInst :  br i1 %exitcond7, label %header.1.preheader, label %kcall.end, !tulip.doall.loop.grid !1058
currInst :  %exitcond6 = icmp ne i32 %indvar.1, 256
currInst :  br i1 %exitcond6, label %kcall.configok, label %latch.0, !tulip.doall.loop.block !1058
currInst :  %16 = bitcast float* %4 to i8*, !dbg !1064
currInst :  %call14 = call i32 @cudaMemcpy(i8* %16, i8* %17, i64 40, i32 2), !dbg !1066, !tulip.target.end.of.map !1058
currInst :  %17 = bitcast float* %4 to i8*, !dbg !1065
currInst :  %call14 = call i32 @cudaMemcpy(i8* %16, i8* %17, i64 40, i32 2), !dbg !1066, !tulip.target.end.of.map !1058
currInst :  %exitcond = icmp ne i64 %indvars.iv, 10, !dbg !1071
currInst :  br i1 %exitcond, label %for.body21, label %for.end34, !dbg !1073
currInst :  %arrayidx23 = getelementptr inbounds float, float* %0, i64 %indvars.iv, !dbg !1074
currInst :  %18 = load float, float* %arrayidx23, align 4, !dbg !1074
currInst :  %conv24 = fpext float %18 to double, !dbg !1074
currInst :  %call31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i64 0, i64 0), double %conv24, double %conv27, double %conv30), !dbg !1078
currInst :  %18 = load float, float* %arrayidx23, align 4, !dbg !1074
currInst :  %conv24 = fpext float %18 to double, !dbg !1074
currInst :  %call31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i64 0, i64 0), double %conv24, double %conv27, double %conv30), !dbg !1078
currInst :  %conv24 = fpext float %18 to double, !dbg !1074
currInst :  %call31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i64 0, i64 0), double %conv24, double %conv27, double %conv30), !dbg !1078
currInst :  %arrayidx26 = getelementptr inbounds float, float* %1, i64 %indvars.iv, !dbg !1076
currInst :  %19 = load float, float* %arrayidx26, align 4, !dbg !1076
currInst :  %conv27 = fpext float %19 to double, !dbg !1076
currInst :  %call31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i64 0, i64 0), double %conv24, double %conv27, double %conv30), !dbg !1078
currInst :  %19 = load float, float* %arrayidx26, align 4, !dbg !1076
currInst :  %conv27 = fpext float %19 to double, !dbg !1076
currInst :  %call31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i64 0, i64 0), double %conv24, double %conv27, double %conv30), !dbg !1078
currInst :  %conv27 = fpext float %19 to double, !dbg !1076
currInst :  %call31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i64 0, i64 0), double %conv24, double %conv27, double %conv30), !dbg !1078
currInst :  %arrayidx29 = getelementptr inbounds float, float* %4, i64 %indvars.iv, !dbg !1077
currInst :  %20 = load float, float* %arrayidx29, align 4, !dbg !1077
currInst :  %conv30 = fpext float %20 to double, !dbg !1077
currInst :  %call31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i64 0, i64 0), double %conv24, double %conv27, double %conv30), !dbg !1078
currInst :  %20 = load float, float* %arrayidx29, align 4, !dbg !1077
currInst :  %conv30 = fpext float %20 to double, !dbg !1077
currInst :  %call31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i64 0, i64 0), double %conv24, double %conv27, double %conv30), !dbg !1078
currInst :  %conv30 = fpext float %20 to double, !dbg !1077
currInst :  %call31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i64 0, i64 0), double %conv24, double %conv27, double %conv30), !dbg !1078
currInst :  %21 = bitcast float* %0 to i8*, !dbg !1084
currInst :  call void @free(i8* %21) #8, !dbg !1085
currInst :  %22 = bitcast float* %1 to i8*, !dbg !1086
currInst :  call void @free(i8* %22) #8, !dbg !1087
currInst :  %23 = bitcast float* %4 to i8*, !dbg !1088
currInst :  call void @free(i8* %23) #8, !dbg !1089
LP->LV 1694:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
LP->L 1694: Loop at depth 1 containing: %for.cond19<header><exiting>,%for.body21,%for.inc32<latch>

nestlevel: i
LP->LV 1694:   %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
LP->L 1694: Loop at depth 1 containing: %header.0<header><exiting>,%header.1.preheader,%header.1,%latch.0<latch>,%kcall.configok,%latch.1
    Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

nestlevel: i
LP->LV 1694:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
LP->L 1694: Loop at depth 1 containing: %for.cond<header><exiting>,%for.body,%for.inc<latch>

nestlevel: i
LP->LV 1694:   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
LP->L 1694: Loop at depth 2 containing: %header.1<header><exiting>,%kcall.configok,%latch.1<latch>

nestlevel: j
SUSAN: getting value name for: 
; Function Attrs: noinline norecurse uwtable
define dso_local i32 @main() #2 !dbg !1011 {
entry:
  %d_a = alloca float*, align 8
  %d_b = alloca float*, align 8
  %d_c = alloca float*, align 8
  %agg.tmp = alloca %struct.dim3, align 4
  %agg.tmp12 = alloca %struct.dim3, align 4
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  %agg.tmp12.coerce = alloca { i64, i32 }, align 4
  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
  %0 = bitcast i8* %call to float*, !dbg !1014
  call void @llvm.dbg.value(metadata float* %0, metadata !1015, metadata !DIExpression()), !dbg !1016
  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
  %1 = bitcast i8* %call1 to float*, !dbg !1018
  call void @llvm.dbg.value(metadata float* %1, metadata !1019, metadata !DIExpression()), !dbg !1016
  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
  call void @llvm.dbg.value(metadata float* %4, metadata !1021, metadata !DIExpression()), !dbg !1016
  call void @llvm.dbg.value(metadata i32 0, metadata !1022, metadata !DIExpression()), !dbg !1024
  br label %for.cond, !dbg !1025

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
  call void @llvm.dbg.value(metadata i64 %indvars.iv8, metadata !1022, metadata !DIExpression()), !dbg !1024
  %exitcond10 = icmp ne i64 %indvars.iv8, 10, !dbg !1026
  br i1 %exitcond10, label %for.body, label %for.end, !dbg !1028

for.body:                                         ; preds = %for.cond
  %2 = trunc i64 %indvars.iv8 to i32, !dbg !1029
  %conv = sitofp i32 %2 to float, !dbg !1029
  %arrayidx = getelementptr inbounds float, float* %0, i64 %indvars.iv8, !dbg !1031
  store float %conv, float* %arrayidx, align 4, !dbg !1032
  %3 = trunc i64 %indvars.iv8 to i32, !dbg !1033
  %conv3 = sitofp i32 %3 to float, !dbg !1033
  %mul = fmul contract float %conv3, 2.000000e+00, !dbg !1034
  %arrayidx5 = getelementptr inbounds float, float* %1, i64 %indvars.iv8, !dbg !1035
  store float %mul, float* %arrayidx5, align 4, !dbg !1036
  br label %for.inc, !dbg !1037

for.inc:                                          ; preds = %for.body
  %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1, !dbg !1038
  call void @llvm.dbg.value(metadata i32 undef, metadata !1022, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !1024
  br label %for.cond, !dbg !1039, !llvm.loop !1040

for.end:                                          ; preds = %for.cond
  %4 = bitcast i8* %call2 to float*, !dbg !1042
  call void @llvm.dbg.declare(metadata float** %d_a, metadata !1043, metadata !DIExpression()), !dbg !1044
  call void @llvm.dbg.declare(metadata float** %d_b, metadata !1045, metadata !DIExpression()), !dbg !1046
  call void @llvm.dbg.declare(metadata float** %d_c, metadata !1047, metadata !DIExpression()), !dbg !1048
  %5 = bitcast float** %d_a to i8**, !dbg !1049
  %call6 = call i32 @cudaMalloc(i8** %5, i64 40), !dbg !1050
  %6 = bitcast float** %d_b to i8**, !dbg !1051
  %call7 = call i32 @cudaMalloc(i8** %6, i64 40), !dbg !1052
  %7 = bitcast float** %d_c to i8**, !dbg !1053
  %call8 = call i32 @cudaMalloc(i8** %7, i64 40), !dbg !1054
  %8 = bitcast float* %0 to i8*, !dbg !1055
  %9 = bitcast float* %0 to i8*, !dbg !1056
  %call9 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 40, i32 1), !dbg !1057, !tulip.target.start.of.map !1058
  call void @llvm.dbg.value(metadata i32 256, metadata !1059, metadata !DIExpression()), !dbg !1016
  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
  call void @llvm.dbg.value(metadata i32 %call11, metadata !1062, metadata !DIExpression()), !dbg !1016
  %dim3gep.0 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 0
  store i32 %call11, i32* %dim3gep.0
  %dim3gep.1 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 1
  store i32 1, i32* %dim3gep.1
  %dim3gep.2 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 2
  store i32 1, i32* %dim3gep.2
  %dim3gep.02 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 0
  store i32 256, i32* %dim3gep.02
  %dim3gep.13 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 1
  store i32 1, i32* %dim3gep.13
  %dim3gep.24 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 2
  store i32 1, i32* %dim3gep.24
  %10 = bitcast { i64, i32 }* %agg.tmp.coerce to i8*, !dbg !1063
  %11 = bitcast %struct.dim3* %agg.tmp to i8*, !dbg !1063
  %12 = call i8* @memcpy(i8* %10, i8* %11, i64 12), !dbg !1063
  %13 = bitcast { i64, i32 }* %agg.tmp12.coerce to i8*, !dbg !1063
  %14 = bitcast %struct.dim3* %agg.tmp12 to i8*, !dbg !1063
  %15 = call i8* @memcpy(i8* %13, i8* %14, i64 12), !dbg !1063
  br label %header.0

header.0:                                         ; preds = %latch.0, %for.end
  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
  %exitcond7 = icmp ne i32 %indvar.0, %call11
  br i1 %exitcond7, label %header.1.preheader, label %kcall.end, !tulip.doall.loop.grid !1058

header.1.preheader:                               ; preds = %header.0
  br label %header.1

header.1:                                         ; preds = %header.1.preheader, %latch.1
  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
  %exitcond6 = icmp ne i32 %indvar.1, 256
  br i1 %exitcond6, label %kcall.configok, label %latch.0, !tulip.doall.loop.block !1058

latch.1:                                          ; preds = %kcall.configok
  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
  br label %header.1

latch.0:                                          ; preds = %header.1
  %indvar.next.0 = add i32 %indvar.0, 1
  br label %header.0

kcall.configok:                                   ; preds = %header.1
  call void @_Z10vector_addPfS_S_i.1(float* %0, float* %1, float* %4, i32 10, i32 %call11, i32 1, i32 1, i32 256, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
  br label %latch.1

kcall.end:                                        ; preds = %header.0
  %16 = bitcast float* %4 to i8*, !dbg !1064
  %17 = bitcast float* %4 to i8*, !dbg !1065
  %call14 = call i32 @cudaMemcpy(i8* %16, i8* %17, i64 40, i32 2), !dbg !1066, !tulip.target.end.of.map !1058
  call void @llvm.dbg.value(metadata i32 0, metadata !1067, metadata !DIExpression()), !dbg !1069
  br label %for.cond19, !dbg !1070

for.cond19:                                       ; preds = %for.inc32, %kcall.end
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !1067, metadata !DIExpression()), !dbg !1069
  %exitcond = icmp ne i64 %indvars.iv, 10, !dbg !1071
  br i1 %exitcond, label %for.body21, label %for.end34, !dbg !1073

for.body21:                                       ; preds = %for.cond19
  %arrayidx23 = getelementptr inbounds float, float* %0, i64 %indvars.iv, !dbg !1074
  %18 = load float, float* %arrayidx23, align 4, !dbg !1074
  %conv24 = fpext float %18 to double, !dbg !1074
  %arrayidx26 = getelementptr inbounds float, float* %1, i64 %indvars.iv, !dbg !1076
  %19 = load float, float* %arrayidx26, align 4, !dbg !1076
  %conv27 = fpext float %19 to double, !dbg !1076
  %arrayidx29 = getelementptr inbounds float, float* %4, i64 %indvars.iv, !dbg !1077
  %20 = load float, float* %arrayidx29, align 4, !dbg !1077
  %conv30 = fpext float %20 to double, !dbg !1077
  %call31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i64 0, i64 0), double %conv24, double %conv27, double %conv30), !dbg !1078
  br label %for.inc32, !dbg !1079

for.inc32:                                        ; preds = %for.body21
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1080
  call void @llvm.dbg.value(metadata i32 undef, metadata !1067, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !1069
  br label %for.cond19, !dbg !1081, !llvm.loop !1082

for.end34:                                        ; preds = %for.cond19
  %21 = bitcast float* %0 to i8*, !dbg !1084
  call void @free(i8* %21) #8, !dbg !1085
  %22 = bitcast float* %1 to i8*, !dbg !1086
  call void @free(i8* %22) #8, !dbg !1087
  %23 = bitcast float* %4 to i8*, !dbg !1088
  call void @free(i8* %23) #8, !dbg !1089
  ret i32 0, !dbg !1090
}

SUSAN: getting value name for:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
inst from IRNaming:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
original name : i
returning name: i
SUSAN: phi related name: i
SUSAN: found in IV2Name map   %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
name:  i
SUSAN: phi related name: i
SUSAN: found in IV2Name map   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
name:  j
SUSAN: phi related name: j
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
original name : i
returning name: i
SUSAN: phi related name: i
=========================SUSAN: IR NAMING BEFORE=====================
  %d_a = alloca float*, align 8 -> d_a
  %d_b = alloca float*, align 8 -> d_b
  %d_c = alloca float*, align 8 -> d_c
  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013 -> h_a
  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024 -> i
  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013 -> h_b
  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013 -> h_c
  %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1, !dbg !1038 -> i
  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061 -> blocksNeeded
  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1 -> j
  %indvar.next.0 = add i32 %indvar.0, 1 -> i
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069 -> i
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1080 -> i
SUSAN: inst:  %12 = call i8* @memcpy(i8* %10, i8* %11, i64 12), !dbg !1063
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %call9 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 40, i32 1), !dbg !1057, !tulip.target.start.of.map !1058
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %d_a = alloca float*, align 8
d_a:  %d_a = alloca float*, align 8
SUSAN: inst:  %d_b = alloca float*, align 8
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
SUSAN: inst:  %d_c = alloca float*, align 8
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
SUSAN: inst:  %agg.tmp = alloca %struct.dim3, align 4
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
SUSAN: inst:  %agg.tmp12 = alloca %struct.dim3, align 4
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
SUSAN: inst:  %agg.tmp.coerce = alloca { i64, i32 }, align 4
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
SUSAN: inst:  %agg.tmp12.coerce = alloca { i64, i32 }, align 4
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
SUSAN: inst:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
SUSAN: inst:  %0 = bitcast i8* %call to float*, !dbg !1014
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
SUSAN: inst:  call void @llvm.dbg.value(metadata float* %0, metadata !1015, metadata !DIExpression()), !dbg !1016
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
SUSAN: inst:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !1067, metadata !DIExpression()), !dbg !1069
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %exitcond = icmp ne i64 %indvars.iv, 10, !dbg !1071
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  br i1 %exitcond, label %for.body21, label %for.end34, !dbg !1073
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %arrayidx23 = getelementptr inbounds float, float* %0, i64 %indvars.iv, !dbg !1074
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %18 = load float, float* %arrayidx23, align 4, !dbg !1074
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %conv24 = fpext float %18 to double, !dbg !1074
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %arrayidx26 = getelementptr inbounds float, float* %1, i64 %indvars.iv, !dbg !1076
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %19 = load float, float* %arrayidx26, align 4, !dbg !1076
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %conv27 = fpext float %19 to double, !dbg !1076
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %arrayidx29 = getelementptr inbounds float, float* %4, i64 %indvars.iv, !dbg !1077
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %20 = load float, float* %arrayidx29, align 4, !dbg !1077
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %conv30 = fpext float %20 to double, !dbg !1077
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %call31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i64 0, i64 0), double %conv24, double %conv27, double %conv30), !dbg !1078
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  br label %for.inc32, !dbg !1079
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
SUSAN: inst:  %1 = bitcast i8* %call1 to float*, !dbg !1018
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
SUSAN: inst:  call void @llvm.dbg.value(metadata float* %1, metadata !1019, metadata !DIExpression()), !dbg !1016
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
SUSAN: inst:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
SUSAN: inst:  call void @llvm.dbg.value(metadata float* %4, metadata !1021, metadata !DIExpression()), !dbg !1016
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 0, metadata !1022, metadata !DIExpression()), !dbg !1024
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
SUSAN: inst:  br label %for.cond, !dbg !1025
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
SUSAN: inst:  call void @llvm.dbg.value(metadata i64 %indvars.iv8, metadata !1022, metadata !DIExpression()), !dbg !1024
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %exitcond10 = icmp ne i64 %indvars.iv8, 10, !dbg !1026
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  br i1 %exitcond10, label %for.body, label %for.end, !dbg !1028
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %2 = trunc i64 %indvars.iv8 to i32, !dbg !1029
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %conv = sitofp i32 %2 to float, !dbg !1029
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %arrayidx = getelementptr inbounds float, float* %0, i64 %indvars.iv8, !dbg !1031
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  store float %conv, float* %arrayidx, align 4, !dbg !1032
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %3 = trunc i64 %indvars.iv8 to i32, !dbg !1033
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %conv3 = sitofp i32 %3 to float, !dbg !1033
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %mul = fmul contract float %conv3, 2.000000e+00, !dbg !1034
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %arrayidx5 = getelementptr inbounds float, float* %1, i64 %indvars.iv8, !dbg !1035
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  store float %mul, float* %arrayidx5, align 4, !dbg !1036
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  br label %for.inc, !dbg !1037
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1, !dbg !1038
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1, !dbg !1038
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 undef, metadata !1022, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !1024
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1, !dbg !1038
SUSAN: inst:  br label %for.cond, !dbg !1039, !llvm.loop !1040
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1, !dbg !1038
SUSAN: inst:  %4 = bitcast i8* %call2 to float*, !dbg !1042
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  call void @llvm.dbg.declare(metadata float** %d_a, metadata !1043, metadata !DIExpression()), !dbg !1044
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  call void @llvm.dbg.declare(metadata float** %d_b, metadata !1045, metadata !DIExpression()), !dbg !1046
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  call void @llvm.dbg.declare(metadata float** %d_c, metadata !1047, metadata !DIExpression()), !dbg !1048
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %5 = bitcast float** %d_a to i8**, !dbg !1049
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %call6 = call i32 @cudaMalloc(i8** %5, i64 40), !dbg !1050
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %6 = bitcast float** %d_b to i8**, !dbg !1051
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %call7 = call i32 @cudaMalloc(i8** %6, i64 40), !dbg !1052
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %7 = bitcast float** %d_c to i8**, !dbg !1053
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %call8 = call i32 @cudaMalloc(i8** %7, i64 40), !dbg !1054
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %8 = bitcast float* %0 to i8*, !dbg !1055
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %9 = bitcast float* %0 to i8*, !dbg !1056
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 256, metadata !1059, metadata !DIExpression()), !dbg !1016
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 %call11, metadata !1062, metadata !DIExpression()), !dbg !1016
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %dim3gep.0 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 0
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  store i32 %call11, i32* %dim3gep.0
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %dim3gep.1 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 1
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  store i32 1, i32* %dim3gep.1
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %dim3gep.2 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 2
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  store i32 1, i32* %dim3gep.2
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %dim3gep.02 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 0
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  store i32 256, i32* %dim3gep.02
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %dim3gep.13 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 1
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  store i32 1, i32* %dim3gep.13
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %dim3gep.24 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 2
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  store i32 1, i32* %dim3gep.24
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %10 = bitcast { i64, i32 }* %agg.tmp.coerce to i8*, !dbg !1063
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %11 = bitcast %struct.dim3* %agg.tmp to i8*, !dbg !1063
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %13 = bitcast { i64, i32 }* %agg.tmp12.coerce to i8*, !dbg !1063
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %14 = bitcast %struct.dim3* %agg.tmp12 to i8*, !dbg !1063
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  br label %header.0
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: inst:  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %exitcond7 = icmp ne i32 %indvar.0, %call11
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  br i1 %exitcond7, label %header.1.preheader, label %kcall.end, !tulip.doall.loop.grid !1058
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  br label %header.1
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %exitcond6 = icmp ne i32 %indvar.1, 256
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  br i1 %exitcond6, label %kcall.configok, label %latch.0, !tulip.doall.loop.block !1058
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  br label %header.1
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %indvar.next.0 = add i32 %indvar.0, 1
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvar.next.0 = add i32 %indvar.0, 1
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  br label %header.0
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvar.next.0 = add i32 %indvar.0, 1
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  call void @_Z10vector_addPfS_S_i.1(float* %0, float* %1, float* %4, i32 10, i32 %call11, i32 1, i32 1, i32 256, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  br label %latch.1
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %16 = bitcast float* %4 to i8*, !dbg !1064
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %17 = bitcast float* %4 to i8*, !dbg !1065
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %call14 = call i32 @cudaMemcpy(i8* %16, i8* %17, i64 40, i32 2), !dbg !1066, !tulip.target.end.of.map !1058
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 0, metadata !1067, metadata !DIExpression()), !dbg !1069
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  br label %for.cond19, !dbg !1070
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1080
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1080
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 undef, metadata !1067, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !1069
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1080
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  br label %for.cond19, !dbg !1081, !llvm.loop !1082
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1080
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %21 = bitcast float* %0 to i8*, !dbg !1084
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  call void @free(i8* %21) #8, !dbg !1085
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %22 = bitcast float* %1 to i8*, !dbg !1086
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  call void @free(i8* %22) #8, !dbg !1087
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %23 = bitcast float* %4 to i8*, !dbg !1088
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  call void @free(i8* %23) #8, !dbg !1089
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  ret i32 0, !dbg !1090
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
j:  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: inst:  %15 = call i8* @memcpy(i8* %13, i8* %14, i64 12), !dbg !1063
blocksNeeded:  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
d_a:  %d_a = alloca float*, align 8
d_b:  %d_b = alloca float*, align 8
d_c:  %d_c = alloca float*, align 8
h_a:  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
h_b:  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
h_c:  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
i:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
=========================SUSAN: IR NAMING=====================
  %d_a = alloca float*, align 8 -> d_a
  %d_b = alloca float*, align 8 -> d_b
  %d_c = alloca float*, align 8 -> d_c
  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013 -> h_a
  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024 -> i
  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013 -> h_b
  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013 -> h_c
  %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1, !dbg !1038 -> i
  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061 -> blocksNeeded
  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1 -> j
  %indvar.next.0 = add i32 %indvar.0, 1 -> i
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069 -> i
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1080 -> i
SUSAN: getting value name for:   %d_a = alloca float*, align 8
inst from IRNaming:   %d_a = alloca float*, align 8
original name : d_a
returning name: d_a
SUSAN: declaring 3252:   %d_a = alloca float*, align 8
SUSAN: getting value name for:   %d_a = alloca float*, align 8
inst from IRNaming:   %d_a = alloca float*, align 8
original name : d_a
returning name: d_a
SUSAN: declaring with reconstructed name 3286: d_a
SUSAN: declaring varName 5264: d_a
SUSAN: printing type at 5885: float*
SUSAN: getting value name for:   %d_b = alloca float*, align 8
inst from IRNaming:   %d_b = alloca float*, align 8
original name : d_b
returning name: d_b
SUSAN: declaring 3252:   %d_b = alloca float*, align 8
SUSAN: getting value name for:   %d_b = alloca float*, align 8
inst from IRNaming:   %d_b = alloca float*, align 8
original name : d_b
returning name: d_b
SUSAN: declaring with reconstructed name 3286: d_b
SUSAN: declaring varName 5264: d_b
SUSAN: printing type at 5885: float*
SUSAN: getting value name for:   %d_c = alloca float*, align 8
inst from IRNaming:   %d_c = alloca float*, align 8
original name : d_c
returning name: d_c
SUSAN: declaring 3252:   %d_c = alloca float*, align 8
SUSAN: getting value name for:   %d_c = alloca float*, align 8
inst from IRNaming:   %d_c = alloca float*, align 8
original name : d_c
returning name: d_c
SUSAN: declaring with reconstructed name 3286: d_c
SUSAN: declaring varName 5264: d_c
SUSAN: printing type at 5885: float*
SUSAN: getting value name for:   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: declaring 3252:   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: declaring varName 5264: agg_2e_tmp
SUSAN: printing type at 5885: %struct.dim3 = type { i32, i32, i32 }
SUSAN: getting value name for:   %agg.tmp12 = alloca %struct.dim3, align 4
SUSAN: declaring 3252:   %agg.tmp12 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp12 = alloca %struct.dim3, align 4
SUSAN: declaring varName 5264: agg_2e_tmp12
SUSAN: printing type at 5885: %struct.dim3 = type { i32, i32, i32 }
SUSAN: getting value name for:   %agg.tmp.coerce = alloca { i64, i32 }, align 4
SUSAN: declaring 3252:   %agg.tmp.coerce = alloca { i64, i32 }, align 4
SUSAN: getting value name for:   %agg.tmp.coerce = alloca { i64, i32 }, align 4
SUSAN: declaring varName 5264: agg_2e_tmp_2e_coerce
SUSAN: printing type at 5885: { i64, i32 }
SUSAN: getting value name for:   %agg.tmp12.coerce = alloca { i64, i32 }, align 4
SUSAN: declaring 3252:   %agg.tmp12.coerce = alloca { i64, i32 }, align 4
SUSAN: getting value name for:   %agg.tmp12.coerce = alloca { i64, i32 }, align 4
SUSAN: declaring varName 5264: agg_2e_tmp12_2e_coerce
SUSAN: printing type at 5885: { i64, i32 }
SUSAN: getting value name for:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
inst from IRNaming:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
original name : h_a
returning name: h_a
SUSAN: declaring varName 5298: h_a
SUSAN: declared locals:
agg_2e_tmp
agg_2e_tmp12
agg_2e_tmp12_2e_coerce
agg_2e_tmp_2e_coerce
d_a
d_b
d_c
SUSAN: declaring 3252:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
SUSAN: getting value name for:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
inst from IRNaming:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
original name : h_a
returning name: h_a
SUSAN: declaring with reconstructed name 3286: h_a
SUSAN: inst at 5950:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
SUSAN: declaring   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
SUSAN: printing type at 5937: i8*
SUSAN: getting value name for:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
inst from IRNaming:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
original name : h_b
returning name: h_b
SUSAN: declaring varName 5298: h_b
SUSAN: declared locals:
agg_2e_tmp
agg_2e_tmp12
agg_2e_tmp12_2e_coerce
agg_2e_tmp_2e_coerce
d_a
d_b
d_c
h_a
SUSAN: declaring 3252:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
SUSAN: getting value name for:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
inst from IRNaming:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
original name : h_b
returning name: h_b
SUSAN: declaring with reconstructed name 3286: h_b
SUSAN: inst at 5950:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
SUSAN: declaring   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
SUSAN: printing type at 5937: i8*
SUSAN: getting value name for:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
inst from IRNaming:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
original name : h_c
returning name: h_c
SUSAN: declaring varName 5298: h_c
SUSAN: declared locals:
agg_2e_tmp
agg_2e_tmp12
agg_2e_tmp12_2e_coerce
agg_2e_tmp_2e_coerce
d_a
d_b
d_c
h_a
h_b
SUSAN: declaring 3252:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
SUSAN: getting value name for:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
inst from IRNaming:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
original name : h_c
returning name: h_c
SUSAN: declaring with reconstructed name 3286: h_c
SUSAN: inst at 5950:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
SUSAN: declaring   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
SUSAN: printing type at 5937: i8*
SUSAN: getting value name for:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
inst from IRNaming:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
original name : i
returning name: i
SUSAN: declaring varName 5298: i
SUSAN: declared locals:
agg_2e_tmp
agg_2e_tmp12
agg_2e_tmp12_2e_coerce
agg_2e_tmp_2e_coerce
d_a
d_b
d_c
h_a
h_b
h_c
SUSAN: declaring 3252:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: getting value name for:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
inst from IRNaming:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
original name : i
returning name: i
SUSAN: declaring with reconstructed name 3286: i
SUSAN: inst at 5950:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: declaring   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: printing type at 5937: i64
SUSAN: getting value name for:   %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1, !dbg !1038
inst from IRNaming:   %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1, !dbg !1038
original name : i
returning name: i
SUSAN: declaring varName 5298: i
SUSAN: getting value name for:   %call6 = call i32 @cudaMalloc(i8** %5, i64 40), !dbg !1050
SUSAN: declaring varName 5298: call6
SUSAN: declared locals:
agg_2e_tmp
agg_2e_tmp12
agg_2e_tmp12_2e_coerce
agg_2e_tmp_2e_coerce
d_a
d_b
d_c
h_a
h_b
h_c
i
SUSAN: declaring 3252:   %call6 = call i32 @cudaMalloc(i8** %5, i64 40), !dbg !1050
SUSAN: getting value name for:   %call6 = call i32 @cudaMalloc(i8** %5, i64 40), !dbg !1050
SUSAN: inst at 5950:   %call6 = call i32 @cudaMalloc(i8** %5, i64 40), !dbg !1050
SUSAN: declaring   %call6 = call i32 @cudaMalloc(i8** %5, i64 40), !dbg !1050
SUSAN: printing type at 5937: i32
SUSAN: getting value name for:   %call7 = call i32 @cudaMalloc(i8** %6, i64 40), !dbg !1052
SUSAN: declaring varName 5298: call7
SUSAN: declared locals:
agg_2e_tmp
agg_2e_tmp12
agg_2e_tmp12_2e_coerce
agg_2e_tmp_2e_coerce
call6
d_a
d_b
d_c
h_a
h_b
h_c
i
SUSAN: declaring 3252:   %call7 = call i32 @cudaMalloc(i8** %6, i64 40), !dbg !1052
SUSAN: getting value name for:   %call7 = call i32 @cudaMalloc(i8** %6, i64 40), !dbg !1052
SUSAN: inst at 5950:   %call7 = call i32 @cudaMalloc(i8** %6, i64 40), !dbg !1052
SUSAN: declaring   %call7 = call i32 @cudaMalloc(i8** %6, i64 40), !dbg !1052
SUSAN: printing type at 5937: i32
SUSAN: getting value name for:   %call8 = call i32 @cudaMalloc(i8** %7, i64 40), !dbg !1054
SUSAN: declaring varName 5298: call8
SUSAN: declared locals:
agg_2e_tmp
agg_2e_tmp12
agg_2e_tmp12_2e_coerce
agg_2e_tmp_2e_coerce
call6
call7
d_a
d_b
d_c
h_a
h_b
h_c
i
SUSAN: declaring 3252:   %call8 = call i32 @cudaMalloc(i8** %7, i64 40), !dbg !1054
SUSAN: getting value name for:   %call8 = call i32 @cudaMalloc(i8** %7, i64 40), !dbg !1054
SUSAN: inst at 5950:   %call8 = call i32 @cudaMalloc(i8** %7, i64 40), !dbg !1054
SUSAN: declaring   %call8 = call i32 @cudaMalloc(i8** %7, i64 40), !dbg !1054
SUSAN: printing type at 5937: i32
SUSAN: getting value name for:   %call9 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 40, i32 1), !dbg !1057, !tulip.target.start.of.map !1058
SUSAN: declaring varName 5298: call9
SUSAN: declared locals:
agg_2e_tmp
agg_2e_tmp12
agg_2e_tmp12_2e_coerce
agg_2e_tmp_2e_coerce
call6
call7
call8
d_a
d_b
d_c
h_a
h_b
h_c
i
SUSAN: declaring 3252:   %call9 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 40, i32 1), !dbg !1057, !tulip.target.start.of.map !1058
SUSAN: getting value name for:   %call9 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 40, i32 1), !dbg !1057, !tulip.target.start.of.map !1058
SUSAN: inst at 5950:   %call9 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 40, i32 1), !dbg !1057, !tulip.target.start.of.map !1058
SUSAN: declaring   %call9 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 40, i32 1), !dbg !1057, !tulip.target.start.of.map !1058
SUSAN: printing type at 5937: i32
SUSAN: getting value name for:   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
inst from IRNaming:   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
original name : blocksNeeded
returning name: blocksNeeded
SUSAN: declaring varName 5298: blocksNeeded
SUSAN: declared locals:
agg_2e_tmp
agg_2e_tmp12
agg_2e_tmp12_2e_coerce
agg_2e_tmp_2e_coerce
call6
call7
call8
call9
d_a
d_b
d_c
h_a
h_b
h_c
i
SUSAN: declaring 3252:   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
SUSAN: getting value name for:   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
inst from IRNaming:   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
original name : blocksNeeded
returning name: blocksNeeded
SUSAN: declaring with reconstructed name 3286: blocksNeeded
SUSAN: inst at 5950:   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
SUSAN: declaring   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
SUSAN: printing type at 5937: i32
SUSAN: getting value name for:   %12 = call i8* @memcpy(i8* %10, i8* %11, i64 12), !dbg !1063
SUSAN: declaring varName 5298: _1
SUSAN: declared locals:
agg_2e_tmp
agg_2e_tmp12
agg_2e_tmp12_2e_coerce
agg_2e_tmp_2e_coerce
blocksNeeded
call6
call7
call8
call9
d_a
d_b
d_c
h_a
h_b
h_c
i
SUSAN: declaring 3252:   %12 = call i8* @memcpy(i8* %10, i8* %11, i64 12), !dbg !1063
SUSAN: getting value name for:   %12 = call i8* @memcpy(i8* %10, i8* %11, i64 12), !dbg !1063
SUSAN: inst at 5950:   %12 = call i8* @memcpy(i8* %10, i8* %11, i64 12), !dbg !1063
SUSAN: declaring   %12 = call i8* @memcpy(i8* %10, i8* %11, i64 12), !dbg !1063
SUSAN: printing type at 5937: i8*
SUSAN: getting value name for:   %15 = call i8* @memcpy(i8* %13, i8* %14, i64 12), !dbg !1063
SUSAN: declaring varName 5298: _2
SUSAN: declared locals:
_1
agg_2e_tmp
agg_2e_tmp12
agg_2e_tmp12_2e_coerce
agg_2e_tmp_2e_coerce
blocksNeeded
call6
call7
call8
call9
d_a
d_b
d_c
h_a
h_b
h_c
i
SUSAN: declaring 3252:   %15 = call i8* @memcpy(i8* %13, i8* %14, i64 12), !dbg !1063
SUSAN: getting value name for:   %15 = call i8* @memcpy(i8* %13, i8* %14, i64 12), !dbg !1063
SUSAN: inst at 5950:   %15 = call i8* @memcpy(i8* %13, i8* %14, i64 12), !dbg !1063
SUSAN: declaring   %15 = call i8* @memcpy(i8* %13, i8* %14, i64 12), !dbg !1063
SUSAN: printing type at 5937: i8*
SUSAN: found in IV2Name map   %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
name:  i
SUSAN: declaring varName 5298: i
SUSAN: found in IV2Name map   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
name:  j
SUSAN: declaring varName 5298: j
SUSAN: declared locals:
_1
_2
agg_2e_tmp
agg_2e_tmp12
agg_2e_tmp12_2e_coerce
agg_2e_tmp_2e_coerce
blocksNeeded
call6
call7
call8
call9
d_a
d_b
d_c
h_a
h_b
h_c
i
SUSAN: declaring 3252:   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found in IV2Name map   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
name:  j
SUSAN: reconstructed variable counter increment for iv:j
SUSAN: inst at 5950:   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: declaring   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: printing type at 5937: i32
SUSAN: getting value name for:   %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
inst from IRNaming:   %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
original name : j
returning name: j
SUSAN: declaring varName 5298: j
SUSAN: getting value name for:   %indvar.next.0 = add i32 %indvar.0, 1
inst from IRNaming:   %indvar.next.0 = add i32 %indvar.0, 1
original name : i
returning name: i
SUSAN: declaring varName 5298: i
SUSAN: getting value name for:   %call14 = call i32 @cudaMemcpy(i8* %16, i8* %17, i64 40, i32 2), !dbg !1066, !tulip.target.end.of.map !1058
SUSAN: declaring varName 5298: call14
SUSAN: declared locals:
_1
_2
agg_2e_tmp
agg_2e_tmp12
agg_2e_tmp12_2e_coerce
agg_2e_tmp_2e_coerce
blocksNeeded
call6
call7
call8
call9
d_a
d_b
d_c
h_a
h_b
h_c
i
j
SUSAN: declaring 3252:   %call14 = call i32 @cudaMemcpy(i8* %16, i8* %17, i64 40, i32 2), !dbg !1066, !tulip.target.end.of.map !1058
SUSAN: getting value name for:   %call14 = call i32 @cudaMemcpy(i8* %16, i8* %17, i64 40, i32 2), !dbg !1066, !tulip.target.end.of.map !1058
SUSAN: inst at 5950:   %call14 = call i32 @cudaMemcpy(i8* %16, i8* %17, i64 40, i32 2), !dbg !1066, !tulip.target.end.of.map !1058
SUSAN: declaring   %call14 = call i32 @cudaMemcpy(i8* %16, i8* %17, i64 40, i32 2), !dbg !1066, !tulip.target.end.of.map !1058
SUSAN: printing type at 5937: i32
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
original name : i
returning name: i
SUSAN: declaring varName 5298: i
SUSAN: getting value name for:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1080
inst from IRNaming:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1080
original name : i
returning name: i
SUSAN: declaring varName 5298: i
SUSAN: am I here 6807??
Linear Region with entry block: entry
SUSAN: printing bb:entry
CBEBackend: printing bb 7082 entry
SUSAN: printing instruction   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013 at 6678
SUSAN: getting value name for:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
inst from IRNaming:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
original name : h_a
returning name: h_a
CBackend: writeOperand 3595: 
; Function Attrs: nounwind
declare dso_local noalias i8* @malloc(i64) #3

SUSAN: getting value name for: 
; Function Attrs: nounwind
declare dso_local noalias i8* @malloc(i64) #3

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 40
CBackend: writeoperand here 3674? 
SUSAN: printing instruction   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013 at 6678
SUSAN: getting value name for:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
inst from IRNaming:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
original name : h_b
returning name: h_b
CBackend: writeOperand 3595: 
; Function Attrs: nounwind
declare dso_local noalias i8* @malloc(i64) #3

SUSAN: getting value name for: 
; Function Attrs: nounwind
declare dso_local noalias i8* @malloc(i64) #3

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 40
CBackend: writeoperand here 3674? 
SUSAN: printing instruction   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013 at 6678
SUSAN: getting value name for:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
inst from IRNaming:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
original name : h_c
returning name: h_c
CBackend: writeOperand 3595: 
; Function Attrs: nounwind
declare dso_local noalias i8* @malloc(i64) #3

SUSAN: getting value name for: 
; Function Attrs: nounwind
declare dso_local noalias i8* @malloc(i64) #3

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 40
CBackend: writeoperand here 3674? 
printing unconditional branch   br label %for.cond, !dbg !1025
Loop Region with entry block: for.cond
term 6818:   br i1 %exitcond10, label %for.body, label %for.end, !dbg !1028
SUSAN: condrelatedinst:  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: condrelatedinst:  %exitcond10 = icmp ne i64 %indvars.iv8, 10, !dbg !1026
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: declaring 3252:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: getting value name for:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
inst from IRNaming:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
original name : i
returning name: i
SUSAN: declaring with reconstructed name 3286: i
CBackend: writeOperand 3595: i64 0
CBackend: writeoperand here 3674? 
SUSAN: getting value name for:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
inst from IRNaming:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
original name : i
returning name: i
SUSAN: declaring 3252:   %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1, !dbg !1038
SUSAN: getting value name for:   %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1, !dbg !1038
inst from IRNaming:   %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1, !dbg !1038
original name : i
returning name: i
SUSAN: declaring with reconstructed name 3286: i
SUSAN: getting value name for:   %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1, !dbg !1038
inst from IRNaming:   %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1, !dbg !1038
original name : i
returning name: i
CBackend: writeOperand 3595:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: getting value name for:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
inst from IRNaming:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 1
CBackend: writeoperand here 3674? 
Linear Region with entry block: for.body
SUSAN: printing bb:for.body
CBEBackend: printing bb 7082 for.body
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: printing instruction   store float %conv, float* %arrayidx, align 4, !dbg !1032 at 6678
CBEBackend: printing store Inst:   store float %conv, float* %arrayidx, align 4, !dbg !1032
CBackend: here? 10442
SUSAN: GEPINST:   %arrayidx = getelementptr inbounds float, float* %0, i64 %indvars.iv8, !dbg !1031
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx = getelementptr inbounds float, float* %0, i64 %indvars.iv8, !dbg !1031
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:  %0 = bitcast i8* %call to float*, !dbg !1014
SUSAN: writing ptr 9994:   %0 = bitcast i8* %call to float*, !dbg !1014
SUSAN: visiting cast:   %0 = bitcast i8* %call to float*, !dbg !1014
SUSAN: printing cast from: i8* to float*
CBackend: writeOperand 3595:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
SUSAN: getting value name for:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
inst from IRNaming:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
original name : h_a
returning name: h_a
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: getting value name for:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
inst from IRNaming:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
CBackend: writeoperand here 3674? 
CBackend: here? 10445
CBackend: writeOperand 3595:   %conv = sitofp i32 %2 to float, !dbg !1029
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: visiting cast:   %conv = sitofp i32 %2 to float, !dbg !1029
CBackend: writeOperand 3595:   %2 = trunc i64 %indvars.iv8 to i32, !dbg !1029
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: visiting cast:   %2 = trunc i64 %indvars.iv8 to i32, !dbg !1029
CBackend: writeOperand 3595:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: getting value name for:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
inst from IRNaming:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: printing instruction   store float %mul, float* %arrayidx5, align 4, !dbg !1036 at 6678
CBEBackend: printing store Inst:   store float %mul, float* %arrayidx5, align 4, !dbg !1036
CBackend: here? 10442
SUSAN: GEPINST:   %arrayidx5 = getelementptr inbounds float, float* %1, i64 %indvars.iv8, !dbg !1035
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx5 = getelementptr inbounds float, float* %1, i64 %indvars.iv8, !dbg !1035
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:  %1 = bitcast i8* %call1 to float*, !dbg !1018
SUSAN: writing ptr 9994:   %1 = bitcast i8* %call1 to float*, !dbg !1018
SUSAN: visiting cast:   %1 = bitcast i8* %call1 to float*, !dbg !1018
SUSAN: printing cast from: i8* to float*
CBackend: writeOperand 3595:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
SUSAN: getting value name for:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
inst from IRNaming:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
original name : h_b
returning name: h_b
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: getting value name for:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
inst from IRNaming:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
CBackend: writeoperand here 3674? 
CBackend: here? 10445
CBackend: writeOperand 3595:   %mul = fmul contract float %conv3, 2.000000e+00, !dbg !1034
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
CBackend: writeOperand 3595:   %conv3 = sitofp i32 %3 to float, !dbg !1033
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: visiting cast:   %conv3 = sitofp i32 %3 to float, !dbg !1033
CBackend: writeOperand 3595:   %3 = trunc i64 %indvars.iv8 to i32, !dbg !1033
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: visiting cast:   %3 = trunc i64 %indvars.iv8 to i32, !dbg !1033
CBackend: writeOperand 3595:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: getting value name for:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
inst from IRNaming:   %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: float 2.000000e+00
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
CBackend: writeoperand here 3674? 
CBackend: here? 10462
printing unconditional branch   br label %for.inc, !dbg !1037
CBERegion: printing latchBB for.inc
CBERegion: I 316:   %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1, !dbg !1038
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
CBERegion: I 316:   call void @llvm.dbg.value(metadata i32 undef, metadata !1022, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
CBERegion: I 316:   br label %for.cond, !dbg !1039, !llvm.loop !1040
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
SUSAN: found IV 784  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
Linear Region with entry block: for.end
SUSAN: printing bb:for.end
CBEBackend: printing bb 7082 for.end
SUSAN: printing instruction   %call6 = call i32 @cudaMalloc(i8** %5, i64 40), !dbg !1050 at 6678
CBackend: writeOperand 3595: 
declare dso_local i32 @cudaMalloc(i8**, i64) #4

SUSAN: getting value name for: 
declare dso_local i32 @cudaMalloc(i8**, i64) #4

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %5 = bitcast float** %d_a to i8**, !dbg !1049
SUSAN: visiting cast:   %5 = bitcast float** %d_a to i8**, !dbg !1049
SUSAN: printing cast from: float** to i8**
CBackend: writeOperand 3595:   %d_a = alloca float*, align 8
SUSAN: getting value name for:   %d_a = alloca float*, align 8
inst from IRNaming:   %d_a = alloca float*, align 8
original name : d_a
returning name: d_a
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 40
CBackend: writeoperand here 3674? 
SUSAN: printing instruction   %call7 = call i32 @cudaMalloc(i8** %6, i64 40), !dbg !1052 at 6678
CBackend: writeOperand 3595: 
declare dso_local i32 @cudaMalloc(i8**, i64) #4

SUSAN: getting value name for: 
declare dso_local i32 @cudaMalloc(i8**, i64) #4

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %6 = bitcast float** %d_b to i8**, !dbg !1051
SUSAN: visiting cast:   %6 = bitcast float** %d_b to i8**, !dbg !1051
SUSAN: printing cast from: float** to i8**
CBackend: writeOperand 3595:   %d_b = alloca float*, align 8
SUSAN: getting value name for:   %d_b = alloca float*, align 8
inst from IRNaming:   %d_b = alloca float*, align 8
original name : d_b
returning name: d_b
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 40
CBackend: writeoperand here 3674? 
SUSAN: printing instruction   %call8 = call i32 @cudaMalloc(i8** %7, i64 40), !dbg !1054 at 6678
CBackend: writeOperand 3595: 
declare dso_local i32 @cudaMalloc(i8**, i64) #4

SUSAN: getting value name for: 
declare dso_local i32 @cudaMalloc(i8**, i64) #4

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %7 = bitcast float** %d_c to i8**, !dbg !1053
SUSAN: visiting cast:   %7 = bitcast float** %d_c to i8**, !dbg !1053
SUSAN: printing cast from: float** to i8**
CBackend: writeOperand 3595:   %d_c = alloca float*, align 8
SUSAN: getting value name for:   %d_c = alloca float*, align 8
inst from IRNaming:   %d_c = alloca float*, align 8
original name : d_c
returning name: d_c
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 40
CBackend: writeoperand here 3674? 
SUSAN: printing instruction   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061 at 6678
SUSAN: getting value name for:   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
inst from IRNaming:   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
original name : blocksNeeded
returning name: blocksNeeded
CBackend: writeOperand 3595: 
; Function Attrs: noinline nounwind uwtable
define internal i32 @_ZL10num_blocksii(i32 %num, i32 %factor) #5 !dbg !1091 {
entry:
  call void @llvm.dbg.value(metadata i32 %num, metadata !1094, metadata !DIExpression()), !dbg !1095
  call void @llvm.dbg.value(metadata i32 %factor, metadata !1096, metadata !DIExpression()), !dbg !1095
  %add = add nsw i32 %num, %factor, !dbg !1097
  %sub = sub nsw i32 %add, 1, !dbg !1098
  %div = sdiv i32 %sub, %factor, !dbg !1099
  ret i32 %div, !dbg !1100
}

SUSAN: getting value name for: 
; Function Attrs: noinline nounwind uwtable
define internal i32 @_ZL10num_blocksii(i32 %num, i32 %factor) #5 !dbg !1091 {
entry:
  call void @llvm.dbg.value(metadata i32 %num, metadata !1094, metadata !DIExpression()), !dbg !1095
  call void @llvm.dbg.value(metadata i32 %factor, metadata !1096, metadata !DIExpression()), !dbg !1095
  %add = add nsw i32 %num, %factor, !dbg !1097
  %sub = sub nsw i32 %add, 1, !dbg !1098
  %div = sdiv i32 %sub, %factor, !dbg !1099
  ret i32 %div, !dbg !1100
}

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 10
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 256
CBackend: writeoperand here 3674? 
SUSAN: printing instruction   store i32 %call11, i32* %dim3gep.0 at 6678
CBEBackend: printing store Inst:   store i32 %call11, i32* %dim3gep.0
CBackend: here? 10442
SUSAN: GEPINST:   %dim3gep.0 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 0
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %dim3gep.0 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 0
SUSAN: accessMemory true
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: is StructType 10074
CBackend: here? 10445
CBackend: writeOperand 3595:   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
SUSAN: getting value name for:   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
inst from IRNaming:   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
original name : blocksNeeded
returning name: blocksNeeded
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: printing instruction   store i32 1, i32* %dim3gep.1 at 6678
CBEBackend: printing store Inst:   store i32 1, i32* %dim3gep.1
CBackend: here? 10442
SUSAN: GEPINST:   %dim3gep.1 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 1
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %dim3gep.1 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 1
SUSAN: accessMemory true
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: is StructType 10074
CBackend: here? 10445
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: printing instruction   store i32 1, i32* %dim3gep.2 at 6678
CBEBackend: printing store Inst:   store i32 1, i32* %dim3gep.2
CBackend: here? 10442
SUSAN: GEPINST:   %dim3gep.2 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 2
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %dim3gep.2 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 2
SUSAN: accessMemory true
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: is StructType 10074
CBackend: here? 10445
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: printing instruction   store i32 256, i32* %dim3gep.02 at 6678
CBEBackend: printing store Inst:   store i32 256, i32* %dim3gep.02
CBackend: here? 10442
SUSAN: GEPINST:   %dim3gep.02 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 0
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %dim3gep.02 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 0
SUSAN: accessMemory true
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975   %agg.tmp12 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp12 = alloca %struct.dim3, align 4
SUSAN: is StructType 10074
CBackend: here? 10445
CBackend: writeOperand 3595: i32 256
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: printing instruction   store i32 1, i32* %dim3gep.13 at 6678
CBEBackend: printing store Inst:   store i32 1, i32* %dim3gep.13
CBackend: here? 10442
SUSAN: GEPINST:   %dim3gep.13 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 1
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %dim3gep.13 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 1
SUSAN: accessMemory true
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975   %agg.tmp12 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp12 = alloca %struct.dim3, align 4
SUSAN: is StructType 10074
CBackend: here? 10445
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: printing instruction   store i32 1, i32* %dim3gep.24 at 6678
CBEBackend: printing store Inst:   store i32 1, i32* %dim3gep.24
CBackend: here? 10442
SUSAN: GEPINST:   %dim3gep.24 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 2
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %dim3gep.24 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 2
SUSAN: accessMemory true
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975   %agg.tmp12 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp12 = alloca %struct.dim3, align 4
SUSAN: is StructType 10074
CBackend: here? 10445
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: here? 10462
SUSAN: printing instruction   %12 = call i8* @memcpy(i8* %10, i8* %11, i64 12), !dbg !1063 at 6678
CBackend: writeOperand 3595: 
declare i8* @memcpy(i8*, i8*, i64)

SUSAN: getting value name for: 
declare i8* @memcpy(i8*, i8*, i64)

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %10 = bitcast { i64, i32 }* %agg.tmp.coerce to i8*, !dbg !1063
SUSAN: visiting cast:   %10 = bitcast { i64, i32 }* %agg.tmp.coerce to i8*, !dbg !1063
SUSAN: printing cast from: { i64, i32 }* to i8*
CBackend: writeOperand 3595:   %agg.tmp.coerce = alloca { i64, i32 }, align 4
SUSAN: getting value name for:   %agg.tmp.coerce = alloca { i64, i32 }, align 4
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %11 = bitcast %struct.dim3* %agg.tmp to i8*, !dbg !1063
SUSAN: visiting cast:   %11 = bitcast %struct.dim3* %agg.tmp to i8*, !dbg !1063
SUSAN: printing cast from: %struct.dim3* to i8*
CBackend: writeOperand 3595:   %agg.tmp = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp = alloca %struct.dim3, align 4
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 12
CBackend: writeoperand here 3674? 
SUSAN: printing instruction   %15 = call i8* @memcpy(i8* %13, i8* %14, i64 12), !dbg !1063 at 6678
CBackend: writeOperand 3595: 
declare i8* @memcpy(i8*, i8*, i64)

SUSAN: getting value name for: 
declare i8* @memcpy(i8*, i8*, i64)

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %13 = bitcast { i64, i32 }* %agg.tmp12.coerce to i8*, !dbg !1063
SUSAN: visiting cast:   %13 = bitcast { i64, i32 }* %agg.tmp12.coerce to i8*, !dbg !1063
SUSAN: printing cast from: { i64, i32 }* to i8*
CBackend: writeOperand 3595:   %agg.tmp12.coerce = alloca { i64, i32 }, align 4
SUSAN: getting value name for:   %agg.tmp12.coerce = alloca { i64, i32 }, align 4
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %14 = bitcast %struct.dim3* %agg.tmp12 to i8*, !dbg !1063
SUSAN: visiting cast:   %14 = bitcast %struct.dim3* %agg.tmp12 to i8*, !dbg !1063
SUSAN: printing cast from: %struct.dim3* to i8*
CBackend: writeOperand 3595:   %agg.tmp12 = alloca %struct.dim3, align 4
SUSAN: getting value name for:   %agg.tmp12 = alloca %struct.dim3, align 4
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 12
CBackend: writeoperand here 3674? 
printing unconditional branch   br label %header.0
Loop Region with entry block: header.0
term 6818:   br i1 %exitcond7, label %header.1.preheader, label %kcall.end, !tulip.doall.loop.grid !1058
SUSAN: condrelatedinst:  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: condrelatedinst:  %exitcond7 = icmp ne i32 %indvar.0, %call11
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: declaring 3252:   %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found in IV2Name map   %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
name:  i
SUSAN: reconstructed variable counter increment for iv:i
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
SUSAN: found in IV2Name map   %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
name:  i
SUSAN: getting value name for:   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
inst from IRNaming:   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
original name : blocksNeeded
returning name: blocksNeeded
SUSAN: declaring 3252:   %indvar.next.0 = add i32 %indvar.0, 1
SUSAN: getting value name for:   %indvar.next.0 = add i32 %indvar.0, 1
inst from IRNaming:   %indvar.next.0 = add i32 %indvar.0, 1
original name : i
returning name: i
SUSAN: declaring with reconstructed name 3286: i
SUSAN: getting value name for:   %indvar.next.0 = add i32 %indvar.0, 1
inst from IRNaming:   %indvar.next.0 = add i32 %indvar.0, 1
original name : i
returning name: i
CBackend: writeOperand 3595:   %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found in IV2Name map   %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
name:  i
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
Linear Region with entry block: header.1.preheader
SUSAN: printing bb:header.1.preheader
CBEBackend: printing bb 7082 header.1.preheader
printing unconditional branch   br label %header.1
Loop Region with entry block: header.1
term 6818:   br i1 %exitcond6, label %kcall.configok, label %latch.0, !tulip.doall.loop.block !1058
SUSAN: condrelatedinst:  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: condrelatedinst:  %exitcond6 = icmp ne i32 %indvar.1, 256
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: declaring 3252:   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found in IV2Name map   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
name:  j
SUSAN: reconstructed variable counter increment for iv:j
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
SUSAN: found in IV2Name map   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
name:  j
SUSAN: declaring 3252:   %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: getting value name for:   %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
inst from IRNaming:   %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
original name : j
returning name: j
SUSAN: declaring with reconstructed name 3286: j
SUSAN: getting value name for:   %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
inst from IRNaming:   %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
original name : j
returning name: j
CBackend: writeOperand 3595:   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found in IV2Name map   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
name:  j
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
Linear Region with entry block: kcall.configok
SUSAN: printing bb:kcall.configok
CBEBackend: printing bb 7082 kcall.configok
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: printing instruction   call void @_Z10vector_addPfS_S_i.1(float* %0, float* %1, float* %4, i32 10, i32 %call11, i32 1, i32 1, i32 256, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0) at 6678
CBackend: writeOperand 3595: 
; Function Attrs: convergent noinline nounwind
define dso_local void @_Z10vector_addPfS_S_i.1(float* %a, float* %b, float* %c, i32 %n, i32 %gridDim.x, i32 %gridDim.y, i32 %gridDim.z, i32 %blockDim.x, i32 %blockDim.y, i32 %blockDim.z, i32 %blockIdx.x, i32 %blockIdx.y, i32 %blockIdx.z, i32 %threadIdx.x, i32 %threadIdx.y, i32 %threadIdx.z) #7 {
entry:
  call void @llvm.dbg.value(metadata float* %a, metadata !1101, metadata !DIExpression()), !dbg !1105
  call void @llvm.dbg.value(metadata float* %b, metadata !1106, metadata !DIExpression()), !dbg !1105
  call void @llvm.dbg.value(metadata float* %c, metadata !1107, metadata !DIExpression()), !dbg !1105
  call void @llvm.dbg.value(metadata i32 %n, metadata !1108, metadata !DIExpression()), !dbg !1105
  call void @llvm.dbg.value(metadata i32 %threadIdx.x, metadata !1109, metadata !DIExpression()), !dbg !1105
  %cmp = icmp slt i32 %threadIdx.x, %n, !dbg !1110
  br i1 %cmp, label %if.then, label %if.end, !dbg !1112

if.then:                                          ; preds = %entry
  %idxprom = sext i32 %threadIdx.x to i64, !dbg !1113
  %arrayidx = getelementptr inbounds float, float* %a, i64 %idxprom, !dbg !1113
  %0 = load float, float* %arrayidx, align 4, !dbg !1113
  %idxprom1 = sext i32 %threadIdx.x to i64, !dbg !1114
  %arrayidx2 = getelementptr inbounds float, float* %b, i64 %idxprom1, !dbg !1114
  %1 = load float, float* %arrayidx2, align 4, !dbg !1114
  %add = fadd contract float %0, %1, !dbg !1115
  %idxprom3 = sext i32 %threadIdx.x to i64, !dbg !1116
  %arrayidx4 = getelementptr inbounds float, float* %c, i64 %idxprom3, !dbg !1116
  store float %add, float* %arrayidx4, align 4, !dbg !1117
  br label %if.end, !dbg !1116

if.end:                                           ; preds = %if.then, %entry
  ret void, !dbg !1118
}

SUSAN: getting value name for: 
; Function Attrs: convergent noinline nounwind
define dso_local void @_Z10vector_addPfS_S_i.1(float* %a, float* %b, float* %c, i32 %n, i32 %gridDim.x, i32 %gridDim.y, i32 %gridDim.z, i32 %blockDim.x, i32 %blockDim.y, i32 %blockDim.z, i32 %blockIdx.x, i32 %blockIdx.y, i32 %blockIdx.z, i32 %threadIdx.x, i32 %threadIdx.y, i32 %threadIdx.z) #7 {
entry:
  call void @llvm.dbg.value(metadata float* %a, metadata !1101, metadata !DIExpression()), !dbg !1105
  call void @llvm.dbg.value(metadata float* %b, metadata !1106, metadata !DIExpression()), !dbg !1105
  call void @llvm.dbg.value(metadata float* %c, metadata !1107, metadata !DIExpression()), !dbg !1105
  call void @llvm.dbg.value(metadata i32 %n, metadata !1108, metadata !DIExpression()), !dbg !1105
  call void @llvm.dbg.value(metadata i32 %threadIdx.x, metadata !1109, metadata !DIExpression()), !dbg !1105
  %cmp = icmp slt i32 %threadIdx.x, %n, !dbg !1110
  br i1 %cmp, label %if.then, label %if.end, !dbg !1112

if.then:                                          ; preds = %entry
  %idxprom = sext i32 %threadIdx.x to i64, !dbg !1113
  %arrayidx = getelementptr inbounds float, float* %a, i64 %idxprom, !dbg !1113
  %0 = load float, float* %arrayidx, align 4, !dbg !1113
  %idxprom1 = sext i32 %threadIdx.x to i64, !dbg !1114
  %arrayidx2 = getelementptr inbounds float, float* %b, i64 %idxprom1, !dbg !1114
  %1 = load float, float* %arrayidx2, align 4, !dbg !1114
  %add = fadd contract float %0, %1, !dbg !1115
  %idxprom3 = sext i32 %threadIdx.x to i64, !dbg !1116
  %arrayidx4 = getelementptr inbounds float, float* %c, i64 %idxprom3, !dbg !1116
  store float %add, float* %arrayidx4, align 4, !dbg !1117
  br label %if.end, !dbg !1116

if.end:                                           ; preds = %if.then, %entry
  ret void, !dbg !1118
}

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %0 = bitcast i8* %call to float*, !dbg !1014
SUSAN: visiting cast:   %0 = bitcast i8* %call to float*, !dbg !1014
SUSAN: printing cast from: i8* to float*
CBackend: writeOperand 3595:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
SUSAN: getting value name for:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
inst from IRNaming:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
original name : h_a
returning name: h_a
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %1 = bitcast i8* %call1 to float*, !dbg !1018
SUSAN: visiting cast:   %1 = bitcast i8* %call1 to float*, !dbg !1018
SUSAN: printing cast from: i8* to float*
CBackend: writeOperand 3595:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
SUSAN: getting value name for:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
inst from IRNaming:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
original name : h_b
returning name: h_b
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %4 = bitcast i8* %call2 to float*, !dbg !1042
SUSAN: visiting cast:   %4 = bitcast i8* %call2 to float*, !dbg !1042
SUSAN: printing cast from: i8* to float*
CBackend: writeOperand 3595:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
SUSAN: getting value name for:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
inst from IRNaming:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
original name : h_c
returning name: h_c
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 10
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
SUSAN: getting value name for:   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
inst from IRNaming:   %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
original name : blocksNeeded
returning name: blocksNeeded
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 256
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found in IV2Name map   %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
name:  i
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found in IV2Name map   %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
name:  j
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
printing unconditional branch   br label %latch.1
CBERegion: printing latchBB latch.1
CBERegion: I 316:   %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
CBERegion: I 316:   br label %header.1
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
SUSAN: found IV 784  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
CBERegion: printing latchBB latch.0
CBERegion: I 316:   %indvar.next.0 = add i32 %indvar.0, 1
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
CBERegion: I 316:   br label %header.0
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
SUSAN: found IV 784  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
Linear Region with entry block: kcall.end
SUSAN: printing bb:kcall.end
CBEBackend: printing bb 7082 kcall.end
printing unconditional branch   br label %for.cond19, !dbg !1070
Loop Region with entry block: for.cond19
term 6818:   br i1 %exitcond, label %for.body21, label %for.end34, !dbg !1073
SUSAN: condrelatedinst:  %exitcond = icmp ne i64 %indvars.iv, 10, !dbg !1071
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: condrelatedinst:  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: declaring 3252:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
original name : i
returning name: i
SUSAN: declaring with reconstructed name 3286: i
CBackend: writeOperand 3595: i64 0
CBackend: writeoperand here 3674? 
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
original name : i
returning name: i
SUSAN: declaring 3252:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1080
SUSAN: getting value name for:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1080
inst from IRNaming:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1080
original name : i
returning name: i
SUSAN: declaring with reconstructed name 3286: i
SUSAN: getting value name for:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1080
inst from IRNaming:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1080
original name : i
returning name: i
CBackend: writeOperand 3595:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i64 1
CBackend: writeoperand here 3674? 
Linear Region with entry block: for.body21
SUSAN: printing bb:for.body21
CBEBackend: printing bb 7082 for.body21
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: printing instruction   %call31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i64 0, i64 0), double %conv24, double %conv27, double %conv30), !dbg !1078 at 6678
CBackend: writeOperand 3595: 
declare dso_local i32 @printf(i8*, ...) #4

SUSAN: getting value name for: 
declare dso_local i32 @printf(i8*, ...) #4

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i64 0, i64 0)
SUSAN: first index is struct or array type
SUSAN: printing Ptr 9975 @.str = private unnamed_addr constant [20 x i8] c"%.1f + %.1f = %.1f\0A\00", align 1
SUSAN: getting value name for: @.str = private unnamed_addr constant [20 x i8] c"%.1f + %.1f = %.1f\0A\00", align 1
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %conv24 = fpext float %18 to double, !dbg !1074
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: visiting cast:   %conv24 = fpext float %18 to double, !dbg !1074
SUSAN: printing cast from: float to double
CBackend: writeOperand 3595:   %18 = load float, float* %arrayidx23, align 4, !dbg !1074
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: loadInst:   %18 = load float, float* %arrayidx23, align 4, !dbg !1074
SUSAN: GEPINST:   %arrayidx23 = getelementptr inbounds float, float* %0, i64 %indvars.iv, !dbg !1074
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx23 = getelementptr inbounds float, float* %0, i64 %indvars.iv, !dbg !1074
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:  %0 = bitcast i8* %call to float*, !dbg !1014
SUSAN: writing ptr 9994:   %0 = bitcast i8* %call to float*, !dbg !1014
SUSAN: visiting cast:   %0 = bitcast i8* %call to float*, !dbg !1014
SUSAN: printing cast from: i8* to float*
CBackend: writeOperand 3595:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
SUSAN: getting value name for:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
inst from IRNaming:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
original name : h_a
returning name: h_a
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %conv27 = fpext float %19 to double, !dbg !1076
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: visiting cast:   %conv27 = fpext float %19 to double, !dbg !1076
SUSAN: printing cast from: float to double
CBackend: writeOperand 3595:   %19 = load float, float* %arrayidx26, align 4, !dbg !1076
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: loadInst:   %19 = load float, float* %arrayidx26, align 4, !dbg !1076
SUSAN: GEPINST:   %arrayidx26 = getelementptr inbounds float, float* %1, i64 %indvars.iv, !dbg !1076
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx26 = getelementptr inbounds float, float* %1, i64 %indvars.iv, !dbg !1076
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:  %1 = bitcast i8* %call1 to float*, !dbg !1018
SUSAN: writing ptr 9994:   %1 = bitcast i8* %call1 to float*, !dbg !1018
SUSAN: visiting cast:   %1 = bitcast i8* %call1 to float*, !dbg !1018
SUSAN: printing cast from: i8* to float*
CBackend: writeOperand 3595:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
SUSAN: getting value name for:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
inst from IRNaming:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
original name : h_b
returning name: h_b
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %conv30 = fpext float %20 to double, !dbg !1077
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: visiting cast:   %conv30 = fpext float %20 to double, !dbg !1077
SUSAN: printing cast from: float to double
CBackend: writeOperand 3595:   %20 = load float, float* %arrayidx29, align 4, !dbg !1077
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: loadInst:   %20 = load float, float* %arrayidx29, align 4, !dbg !1077
SUSAN: GEPINST:   %arrayidx29 = getelementptr inbounds float, float* %4, i64 %indvars.iv, !dbg !1077
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx29 = getelementptr inbounds float, float* %4, i64 %indvars.iv, !dbg !1077
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:  %4 = bitcast i8* %call2 to float*, !dbg !1042
SUSAN: writing ptr 9994:   %4 = bitcast i8* %call2 to float*, !dbg !1042
SUSAN: visiting cast:   %4 = bitcast i8* %call2 to float*, !dbg !1042
SUSAN: printing cast from: i8* to float*
CBackend: writeOperand 3595:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
SUSAN: getting value name for:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
inst from IRNaming:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
original name : h_c
returning name: h_c
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: getting value name for:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
inst from IRNaming:   %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
original name : i
returning name: i
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
CBackend: writeoperand here 3674? 
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
CBackend: writeoperand here 3674? 
printing unconditional branch   br label %for.inc32, !dbg !1079
CBERegion: printing latchBB for.inc32
CBERegion: I 316:   %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1080
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
CBERegion: I 316:   call void @llvm.dbg.value(metadata i32 undef, metadata !1067, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
CBERegion: I 316:   br label %for.cond19, !dbg !1081, !llvm.loop !1082
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
SUSAN: found IV 784  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
Linear Region with entry block: for.end34
SUSAN: printing bb:for.end34
CBEBackend: printing bb 7082 for.end34
SUSAN: printing instruction   call void @free(i8* %21) #8, !dbg !1085 at 6678
CBackend: writeOperand 3595: 
; Function Attrs: nounwind
declare dso_local void @free(i8*) #3

SUSAN: getting value name for: 
; Function Attrs: nounwind
declare dso_local void @free(i8*) #3

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %21 = bitcast float* %0 to i8*, !dbg !1084
SUSAN: visiting cast:   %21 = bitcast float* %0 to i8*, !dbg !1084
SUSAN: printing cast from: float* to i8*
CBackend: writeOperand 3595:   %0 = bitcast i8* %call to float*, !dbg !1014
SUSAN: visiting cast:   %0 = bitcast i8* %call to float*, !dbg !1014
SUSAN: printing cast from: i8* to float*
CBackend: writeOperand 3595:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
SUSAN: getting value name for:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
inst from IRNaming:   %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
original name : h_a
returning name: h_a
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
SUSAN: printing instruction   call void @free(i8* %22) #8, !dbg !1087 at 6678
CBackend: writeOperand 3595: 
; Function Attrs: nounwind
declare dso_local void @free(i8*) #3

SUSAN: getting value name for: 
; Function Attrs: nounwind
declare dso_local void @free(i8*) #3

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %22 = bitcast float* %1 to i8*, !dbg !1086
SUSAN: visiting cast:   %22 = bitcast float* %1 to i8*, !dbg !1086
SUSAN: printing cast from: float* to i8*
CBackend: writeOperand 3595:   %1 = bitcast i8* %call1 to float*, !dbg !1018
SUSAN: visiting cast:   %1 = bitcast i8* %call1 to float*, !dbg !1018
SUSAN: printing cast from: i8* to float*
CBackend: writeOperand 3595:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
SUSAN: getting value name for:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
inst from IRNaming:   %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
original name : h_b
returning name: h_b
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
SUSAN: printing instruction   call void @free(i8* %23) #8, !dbg !1089 at 6678
CBackend: writeOperand 3595: 
; Function Attrs: nounwind
declare dso_local void @free(i8*) #3

SUSAN: getting value name for: 
; Function Attrs: nounwind
declare dso_local void @free(i8*) #3

CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %23 = bitcast float* %4 to i8*, !dbg !1088
SUSAN: visiting cast:   %23 = bitcast float* %4 to i8*, !dbg !1088
SUSAN: printing cast from: float* to i8*
CBackend: writeOperand 3595:   %4 = bitcast i8* %call2 to float*, !dbg !1042
SUSAN: visiting cast:   %4 = bitcast i8* %call2 to float*, !dbg !1042
SUSAN: printing cast from: i8* to float*
CBackend: writeOperand 3595:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
SUSAN: getting value name for:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
inst from IRNaming:   %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
original name : h_c
returning name: h_c
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 0
CBackend: writeoperand here 3674? 
CBackend: iterating function 1759: malloc
CBackend: iterating function 1759: cudaMalloc
CBackend: iterating function 1759: cudaMemcpy
CBackend: iterating function 1759: _ZL10num_blocksii
CBackend: printing function 1770_ZL10num_blocksii
=========LOOP PROFILES=========
SUSAN: BB:
entry:
  call void @llvm.dbg.value(metadata i32 %num, metadata !1014, metadata !DIExpression()), !dbg !1015
  call void @llvm.dbg.value(metadata i32 %factor, metadata !1016, metadata !DIExpression()), !dbg !1015
  %add = add nsw i32 %num, %factor, !dbg !1017
  %sub = sub nsw i32 %add, 1, !dbg !1018
  %div = sdiv i32 %sub, %factor, !dbg !1019
  ret i32 %div, !dbg !1020

SUSAN: entry block is a linear region! entry
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 %num, metadata !1094, metadata !DIExpression()), !dbg !1095
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 %factor, metadata !1096, metadata !DIExpression()), !dbg !1095
========== IV MAP==========
currInst :  %add = add nsw i32 %num, %factor, !dbg !1017
currInst :  %sub = sub nsw i32 %add, 1, !dbg !1018
currInst :  %div = sdiv i32 %sub, %factor, !dbg !1019
SUSAN: add () to inst:   %add = add nsw i32 %num, %factor, !dbg !1017
currInst :  %sub = sub nsw i32 %add, 1, !dbg !1018
currInst :  %div = sdiv i32 %sub, %factor, !dbg !1019
SUSAN: add () to inst:   %sub = sub nsw i32 %add, 1, !dbg !1018
currInst :  %div = sdiv i32 %sub, %factor, !dbg !1019
currInst :  ret i32 %div, !dbg !1020
SUSAN: getting value name for: 
; Function Attrs: noinline nounwind uwtable
define internal i32 @_ZL10num_blocksii(i32 %num, i32 %factor) #5 !dbg !1091 {
entry:
  call void @llvm.dbg.value(metadata i32 %num, metadata !1094, metadata !DIExpression()), !dbg !1095
  call void @llvm.dbg.value(metadata i32 %factor, metadata !1096, metadata !DIExpression()), !dbg !1095
  %add = add nsw i32 %num, %factor, !dbg !1097
  %sub = sub nsw i32 %add, 1, !dbg !1098
  %div = sdiv i32 %sub, %factor, !dbg !1099
  ret i32 %div, !dbg !1100
}

SUSAN: found argument 6346: i32 %num
CBackend: varname: num
  call void @llvm.dbg.value(metadata i32 %num, metadata !1094, metadata !DIExpression()), !dbg !1095
SUSAN: found argument 6346: i32 %factor
CBackend: varname: factor
  call void @llvm.dbg.value(metadata i32 %factor, metadata !1096, metadata !DIExpression()), !dbg !1095
=========================SUSAN: IR NAMING BEFORE=====================
i32 %num -> num
i32 %factor -> factor
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 %num, metadata !1094, metadata !DIExpression()), !dbg !1095
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 %factor, metadata !1096, metadata !DIExpression()), !dbg !1095
SUSAN: inst:  %add = add nsw i32 %num, %factor, !dbg !1017
SUSAN: inst:  %sub = sub nsw i32 %add, 1, !dbg !1018
SUSAN: inst:  %div = sdiv i32 %sub, %factor, !dbg !1019
SUSAN: inst:  ret i32 %div, !dbg !1020
=========================SUSAN: IR NAMING=====================
i32 %num -> num
i32 %factor -> factor
SUSAN: getting value name for: i32 %num
inst from IRNaming: i32 %num
original name : num
returning name: num
SUSAN: getting value name for: i32 %factor
inst from IRNaming: i32 %factor
original name : factor
returning name: factor
SUSAN: am I here 6807??
Linear Region with entry block: entry
SUSAN: printing bb:entry
CBEBackend: printing bb 7082 entry
CBackend: writeOperand 3595:   %div = sdiv i32 %sub, %factor, !dbg !1019
CBackend: writeOperand 3595:   %sub = sub nsw i32 %add, 1, !dbg !1018
CBackend: writeOperand 3595:   %add = add nsw i32 %num, %factor, !dbg !1017
CBackend: writeOperand 3595: i32 %num
SUSAN: getting value name for: i32 %num
inst from IRNaming: i32 %num
original name : num
returning name: num
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 %factor
SUSAN: getting value name for: i32 %factor
inst from IRNaming: i32 %factor
original name : factor
returning name: factor
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 1
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 %factor
SUSAN: getting value name for: i32 %factor
inst from IRNaming: i32 %factor
original name : factor
returning name: factor
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: iterating function 1759: llvm.memcpy.p0i8.p0i8.i64
CBackend: iterating function 1759: cudaConfigureCall
CBackend: iterating function 1759: cudaFree
CBackend: iterating function 1759: printf
CBackend: iterating function 1759: free
CBackend: iterating function 1759: _Z10vector_addPfS_S_i.1
CBackend: printing function 1770_Z10vector_addPfS_S_i.1
=========LOOP PROFILES=========
SUSAN: opnd0i32 %threadIdx.x
SUSAN: opnd1i32 %n
SUSAN: BB:
entry:
  call void @llvm.dbg.value(metadata float* %a, metadata !1011, metadata !DIExpression()), !dbg !1015
  call void @llvm.dbg.value(metadata float* %b, metadata !1016, metadata !DIExpression()), !dbg !1015
  call void @llvm.dbg.value(metadata float* %c, metadata !1017, metadata !DIExpression()), !dbg !1015
  call void @llvm.dbg.value(metadata i32 %n, metadata !1018, metadata !DIExpression()), !dbg !1015
  call void @llvm.dbg.value(metadata i32 %threadIdx.x, metadata !1019, metadata !DIExpression()), !dbg !1015
  %cmp = icmp slt i32 %threadIdx.x, %n, !dbg !1020
  br i1 %cmp, label %if.then, label %if.end, !dbg !1022

SUSAN: BB:
if.then:                                          ; preds = %entry
  %idxprom = sext i32 %threadIdx.x to i64, !dbg !1023
  %arrayidx = getelementptr inbounds float, float* %a, i64 %idxprom, !dbg !1023
  %0 = load float, float* %arrayidx, align 4, !dbg !1023
  %idxprom1 = sext i32 %threadIdx.x to i64, !dbg !1024
  %arrayidx2 = getelementptr inbounds float, float* %b, i64 %idxprom1, !dbg !1024
  %1 = load float, float* %arrayidx2, align 4, !dbg !1024
  %add = fadd contract float %0, %1, !dbg !1025
  %idxprom3 = sext i32 %threadIdx.x to i64, !dbg !1026
  %arrayidx4 = getelementptr inbounds float, float* %c, i64 %idxprom3, !dbg !1026
  store float %add, float* %arrayidx4, align 4, !dbg !1027
  br label %if.end, !dbg !1026

SUSAN: BB:
if.end:                                           ; preds = %if.then, %entry
  ret void, !dbg !1028

SUSAN: entry block is an if-else region! entry
creating if-else region for entryBB: entry
1
1
SUSAN: marking both branches
SUSAN: entry block is a linear region! if.then
CBERegion: including if.then in a linear region
CBERegion: nextBB 
if.then:                                          ; preds = %entry
  %idxprom = sext i32 %threadIdx.x to i64, !dbg !1023
  %arrayidx = getelementptr inbounds float, float* %a, i64 %idxprom, !dbg !1023
  %0 = load float, float* %arrayidx, align 4, !dbg !1023
  %idxprom1 = sext i32 %threadIdx.x to i64, !dbg !1024
  %arrayidx2 = getelementptr inbounds float, float* %b, i64 %idxprom1, !dbg !1024
  %1 = load float, float* %arrayidx2, align 4, !dbg !1024
  %add = fadd contract float %0, %1, !dbg !1025
  %idxprom3 = sext i32 %threadIdx.x to i64, !dbg !1026
  %arrayidx4 = getelementptr inbounds float, float* %c, i64 %idxprom3, !dbg !1026
  store float %add, float* %arrayidx4, align 4, !dbg !1027
  br label %if.end, !dbg !1026

SUSAN: currbb 562: if.end
CBERegion: nextEntryBB 121: if.end
=================SUSAN: END OF marking region : entry==================
SUSAN: nextRegionEntryBB if.end
SUSAN: entry block is a linear region! if.end
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata float* %a, metadata !1101, metadata !DIExpression()), !dbg !1105
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata float* %b, metadata !1106, metadata !DIExpression()), !dbg !1105
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata float* %c, metadata !1107, metadata !DIExpression()), !dbg !1105
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 %n, metadata !1108, metadata !DIExpression()), !dbg !1105
SUSAN: CI at 1400:   call void @llvm.dbg.value(metadata i32 %threadIdx.x, metadata !1109, metadata !DIExpression()), !dbg !1105
========== IV MAP==========
currInst :  %cmp = icmp slt i32 %threadIdx.x, %n, !dbg !1020
currInst :  br i1 %cmp, label %if.then, label %if.end, !dbg !1022
currInst :  %idxprom = sext i32 %threadIdx.x to i64, !dbg !1023
currInst :  %arrayidx = getelementptr inbounds float, float* %a, i64 %idxprom, !dbg !1023
currInst :  %0 = load float, float* %arrayidx, align 4, !dbg !1023
currInst :  %add = fadd contract float %0, %1, !dbg !1025
currInst :  store float %add, float* %arrayidx4, align 4, !dbg !1027
currInst :  %arrayidx = getelementptr inbounds float, float* %a, i64 %idxprom, !dbg !1023
currInst :  %0 = load float, float* %arrayidx, align 4, !dbg !1023
currInst :  %add = fadd contract float %0, %1, !dbg !1025
currInst :  store float %add, float* %arrayidx4, align 4, !dbg !1027
currInst :  %0 = load float, float* %arrayidx, align 4, !dbg !1023
currInst :  %add = fadd contract float %0, %1, !dbg !1025
currInst :  store float %add, float* %arrayidx4, align 4, !dbg !1027
currInst :  %idxprom1 = sext i32 %threadIdx.x to i64, !dbg !1024
currInst :  %arrayidx2 = getelementptr inbounds float, float* %b, i64 %idxprom1, !dbg !1024
currInst :  %1 = load float, float* %arrayidx2, align 4, !dbg !1024
currInst :  %add = fadd contract float %0, %1, !dbg !1025
currInst :  store float %add, float* %arrayidx4, align 4, !dbg !1027
currInst :  %arrayidx2 = getelementptr inbounds float, float* %b, i64 %idxprom1, !dbg !1024
currInst :  %1 = load float, float* %arrayidx2, align 4, !dbg !1024
currInst :  %add = fadd contract float %0, %1, !dbg !1025
currInst :  store float %add, float* %arrayidx4, align 4, !dbg !1027
currInst :  %1 = load float, float* %arrayidx2, align 4, !dbg !1024
currInst :  %add = fadd contract float %0, %1, !dbg !1025
currInst :  store float %add, float* %arrayidx4, align 4, !dbg !1027
currInst :  %add = fadd contract float %0, %1, !dbg !1025
currInst :  store float %add, float* %arrayidx4, align 4, !dbg !1027
currInst :  %idxprom3 = sext i32 %threadIdx.x to i64, !dbg !1026
currInst :  %arrayidx4 = getelementptr inbounds float, float* %c, i64 %idxprom3, !dbg !1026
currInst :  store float %add, float* %arrayidx4, align 4, !dbg !1027
currInst :  %arrayidx4 = getelementptr inbounds float, float* %c, i64 %idxprom3, !dbg !1026
currInst :  store float %add, float* %arrayidx4, align 4, !dbg !1027
SUSAN: getting value name for: 
; Function Attrs: convergent noinline nounwind
define dso_local void @_Z10vector_addPfS_S_i.1(float* %a, float* %b, float* %c, i32 %n, i32 %gridDim.x, i32 %gridDim.y, i32 %gridDim.z, i32 %blockDim.x, i32 %blockDim.y, i32 %blockDim.z, i32 %blockIdx.x, i32 %blockIdx.y, i32 %blockIdx.z, i32 %threadIdx.x, i32 %threadIdx.y, i32 %threadIdx.z) #7 {
entry:
  call void @llvm.dbg.value(metadata float* %a, metadata !1101, metadata !DIExpression()), !dbg !1105
  call void @llvm.dbg.value(metadata float* %b, metadata !1106, metadata !DIExpression()), !dbg !1105
  call void @llvm.dbg.value(metadata float* %c, metadata !1107, metadata !DIExpression()), !dbg !1105
  call void @llvm.dbg.value(metadata i32 %n, metadata !1108, metadata !DIExpression()), !dbg !1105
  call void @llvm.dbg.value(metadata i32 %threadIdx.x, metadata !1109, metadata !DIExpression()), !dbg !1105
  %cmp = icmp slt i32 %threadIdx.x, %n, !dbg !1110
  br i1 %cmp, label %if.then, label %if.end, !dbg !1112

if.then:                                          ; preds = %entry
  %idxprom = sext i32 %threadIdx.x to i64, !dbg !1113
  %arrayidx = getelementptr inbounds float, float* %a, i64 %idxprom, !dbg !1113
  %0 = load float, float* %arrayidx, align 4, !dbg !1113
  %idxprom1 = sext i32 %threadIdx.x to i64, !dbg !1114
  %arrayidx2 = getelementptr inbounds float, float* %b, i64 %idxprom1, !dbg !1114
  %1 = load float, float* %arrayidx2, align 4, !dbg !1114
  %add = fadd contract float %0, %1, !dbg !1115
  %idxprom3 = sext i32 %threadIdx.x to i64, !dbg !1116
  %arrayidx4 = getelementptr inbounds float, float* %c, i64 %idxprom3, !dbg !1116
  store float %add, float* %arrayidx4, align 4, !dbg !1117
  br label %if.end, !dbg !1116

if.end:                                           ; preds = %if.then, %entry
  ret void, !dbg !1118
}

SUSAN: found argument 6346: float* %a
CBackend: varname: a
  call void @llvm.dbg.value(metadata float* %a, metadata !1101, metadata !DIExpression()), !dbg !1105
SUSAN: found argument 6346: float* %b
CBackend: varname: b
  call void @llvm.dbg.value(metadata float* %b, metadata !1106, metadata !DIExpression()), !dbg !1105
SUSAN: found argument 6346: float* %c
CBackend: varname: c
  call void @llvm.dbg.value(metadata float* %c, metadata !1107, metadata !DIExpression()), !dbg !1105
SUSAN: found argument 6346: i32 %n
CBackend: varname: n
  call void @llvm.dbg.value(metadata i32 %n, metadata !1108, metadata !DIExpression()), !dbg !1105
=========================SUSAN: IR NAMING BEFORE=====================
float* %a -> a
float* %b -> b
float* %c -> c
i32 %n -> n
SUSAN: inst:  call void @llvm.dbg.value(metadata float* %a, metadata !1101, metadata !DIExpression()), !dbg !1105
SUSAN: inst:  call void @llvm.dbg.value(metadata float* %b, metadata !1106, metadata !DIExpression()), !dbg !1105
SUSAN: inst:  call void @llvm.dbg.value(metadata float* %c, metadata !1107, metadata !DIExpression()), !dbg !1105
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 %n, metadata !1108, metadata !DIExpression()), !dbg !1105
SUSAN: inst:  call void @llvm.dbg.value(metadata i32 %threadIdx.x, metadata !1109, metadata !DIExpression()), !dbg !1105
SUSAN: inst:  %cmp = icmp slt i32 %threadIdx.x, %n, !dbg !1020
SUSAN: inst:  br i1 %cmp, label %if.then, label %if.end, !dbg !1022
SUSAN: inst:  %idxprom = sext i32 %threadIdx.x to i64, !dbg !1023
SUSAN: inst:  %arrayidx = getelementptr inbounds float, float* %a, i64 %idxprom, !dbg !1023
SUSAN: inst:  %0 = load float, float* %arrayidx, align 4, !dbg !1023
SUSAN: inst:  %idxprom1 = sext i32 %threadIdx.x to i64, !dbg !1024
SUSAN: inst:  %arrayidx2 = getelementptr inbounds float, float* %b, i64 %idxprom1, !dbg !1024
SUSAN: inst:  %1 = load float, float* %arrayidx2, align 4, !dbg !1024
SUSAN: inst:  %add = fadd contract float %0, %1, !dbg !1025
SUSAN: inst:  %idxprom3 = sext i32 %threadIdx.x to i64, !dbg !1026
SUSAN: inst:  %arrayidx4 = getelementptr inbounds float, float* %c, i64 %idxprom3, !dbg !1026
SUSAN: inst:  store float %add, float* %arrayidx4, align 4, !dbg !1027
SUSAN: inst:  br label %if.end, !dbg !1026
SUSAN: inst:  ret void, !dbg !1028
=========================SUSAN: IR NAMING=====================
float* %a -> a
float* %b -> b
float* %c -> c
i32 %n -> n
SUSAN: getting value name for: float* %a
inst from IRNaming: float* %a
original name : a
returning name: a
SUSAN: getting value name for: float* %b
inst from IRNaming: float* %b
original name : b
returning name: b
SUSAN: getting value name for: float* %c
inst from IRNaming: float* %c
original name : c
returning name: c
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
SUSAN: getting value name for: i32 %gridDim.x
SUSAN: getting value name for: i32 %gridDim.y
SUSAN: getting value name for: i32 %gridDim.z
SUSAN: getting value name for: i32 %blockDim.x
SUSAN: getting value name for: i32 %blockDim.y
SUSAN: getting value name for: i32 %blockDim.z
SUSAN: getting value name for: i32 %blockIdx.x
SUSAN: getting value name for: i32 %blockIdx.y
SUSAN: getting value name for: i32 %blockIdx.z
SUSAN: getting value name for: i32 %threadIdx.x
SUSAN: getting value name for: i32 %threadIdx.y
SUSAN: getting value name for: i32 %threadIdx.z
SUSAN: am I here 6807??
IfElse Region with entry block: entry
thenSubRegions : 
CBackend: writeOperand 3595:   %cmp = icmp slt i32 %threadIdx.x, %n, !dbg !1020
CBackend: writeOperand 3595: i32 %threadIdx.x
SUSAN: getting value name for: i32 %threadIdx.x
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595: i32 %n
SUSAN: getting value name for: i32 %n
inst from IRNaming: i32 %n
original name : n
returning name: n
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
Linear Region with entry block: if.then
SUSAN: printing bb:if.then
CBEBackend: printing bb 7082 if.then
SUSAN: printing instruction   store float %add, float* %arrayidx4, align 4, !dbg !1027 at 6678
CBEBackend: printing store Inst:   store float %add, float* %arrayidx4, align 4, !dbg !1027
CBackend: here? 10442
SUSAN: GEPINST:   %arrayidx4 = getelementptr inbounds float, float* %c, i64 %idxprom3, !dbg !1026
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx4 = getelementptr inbounds float, float* %c, i64 %idxprom3, !dbg !1026
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:float* %c
SUSAN: writing ptr 9994: float* %c
SUSAN: getting value name for: float* %c
inst from IRNaming: float* %c
original name : c
returning name: c
CBackend: writeOperand 3595:   %idxprom3 = sext i32 %threadIdx.x to i64, !dbg !1026
SUSAN: visiting cast:   %idxprom3 = sext i32 %threadIdx.x to i64, !dbg !1026
CBackend: writeOperand 3595: i32 %threadIdx.x
SUSAN: getting value name for: i32 %threadIdx.x
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: here? 10445
CBackend: writeOperand 3595:   %add = fadd contract float %0, %1, !dbg !1025
CBackend: writeOperand 3595:   %0 = load float, float* %arrayidx, align 4, !dbg !1023
SUSAN: loadInst:   %0 = load float, float* %arrayidx, align 4, !dbg !1023
SUSAN: GEPINST:   %arrayidx = getelementptr inbounds float, float* %a, i64 %idxprom, !dbg !1023
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx = getelementptr inbounds float, float* %a, i64 %idxprom, !dbg !1023
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:float* %a
SUSAN: writing ptr 9994: float* %a
SUSAN: getting value name for: float* %a
inst from IRNaming: float* %a
original name : a
returning name: a
CBackend: writeOperand 3595:   %idxprom = sext i32 %threadIdx.x to i64, !dbg !1023
SUSAN: visiting cast:   %idxprom = sext i32 %threadIdx.x to i64, !dbg !1023
CBackend: writeOperand 3595: i32 %threadIdx.x
SUSAN: getting value name for: i32 %threadIdx.x
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeOperand 3595:   %1 = load float, float* %arrayidx2, align 4, !dbg !1024
SUSAN: loadInst:   %1 = load float, float* %arrayidx2, align 4, !dbg !1024
SUSAN: GEPINST:   %arrayidx2 = getelementptr inbounds float, float* %b, i64 %idxprom1, !dbg !1024
SUSAN: dereferenceTimes = 1
SUSAN: printing GEP:   %arrayidx2 = getelementptr inbounds float, float* %b, i64 %idxprom1, !dbg !1024
SUSAN: accessMemory true
SUSAN: first index is integer/pointertype type
SUSAN: writing ptr 10000:float* %b
SUSAN: writing ptr 9994: float* %b
SUSAN: getting value name for: float* %b
inst from IRNaming: float* %b
original name : b
returning name: b
CBackend: writeOperand 3595:   %idxprom1 = sext i32 %threadIdx.x to i64, !dbg !1024
SUSAN: visiting cast:   %idxprom1 = sext i32 %threadIdx.x to i64, !dbg !1024
CBackend: writeOperand 3595: i32 %threadIdx.x
SUSAN: getting value name for: i32 %threadIdx.x
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: writeoperand here 3674? 
CBackend: here? 10462
printing unconditional branch   br label %if.end, !dbg !1026
Linear Region with entry block: if.end
SUSAN: printing bb:if.end
CBEBackend: printing bb 7082 if.end
CBackend: iterating function 1759: llvm.dbg.value
CBackend: iterating function 1759: memcpy
TOTAL VARIABLES: 28
RECONSTRUCTED VARIABLES: 17
SUSAN: getting value name for: 
declare dso_local i32 @cudaSetupArgument(i8*, i64, i64)

SUSAN: getting value name for: 
declare dso_local i32 @cudaLaunch(i8*)

SUSAN: getting value name for: 
; Function Attrs: noinline norecurse uwtable
define dso_local i32 @main() #2 !dbg !1011 {
entry:
  %d_a = alloca float*, align 8
  %d_b = alloca float*, align 8
  %d_c = alloca float*, align 8
  %agg.tmp = alloca %struct.dim3, align 4
  %agg.tmp12 = alloca %struct.dim3, align 4
  %agg.tmp.coerce = alloca { i64, i32 }, align 4
  %agg.tmp12.coerce = alloca { i64, i32 }, align 4
  %call = call noalias i8* @malloc(i64 40) #8, !dbg !1012, !tulip.target.mapdata.to !1013
  %0 = bitcast i8* %call to float*, !dbg !1014
  call void @llvm.dbg.value(metadata float* %0, metadata !1015, metadata !DIExpression()), !dbg !1016
  %call1 = call noalias i8* @malloc(i64 40) #8, !dbg !1017, !tulip.target.mapdata.to !1013
  %1 = bitcast i8* %call1 to float*, !dbg !1018
  call void @llvm.dbg.value(metadata float* %1, metadata !1019, metadata !DIExpression()), !dbg !1016
  %call2 = call noalias i8* @malloc(i64 40) #8, !dbg !1020, !tulip.target.mapdata.from !1013
  call void @llvm.dbg.value(metadata float* %4, metadata !1021, metadata !DIExpression()), !dbg !1016
  call void @llvm.dbg.value(metadata i32 0, metadata !1022, metadata !DIExpression()), !dbg !1024
  br label %for.cond, !dbg !1025

for.cond:                                         ; preds = %for.inc, %entry
  %indvars.iv8 = phi i64 [ %indvars.iv.next9, %for.inc ], [ 0, %entry ], !dbg !1024
  call void @llvm.dbg.value(metadata i64 %indvars.iv8, metadata !1022, metadata !DIExpression()), !dbg !1024
  %exitcond10 = icmp ne i64 %indvars.iv8, 10, !dbg !1026
  br i1 %exitcond10, label %for.body, label %for.end, !dbg !1028

for.body:                                         ; preds = %for.cond
  %2 = trunc i64 %indvars.iv8 to i32, !dbg !1029
  %conv = sitofp i32 %2 to float, !dbg !1029
  %arrayidx = getelementptr inbounds float, float* %0, i64 %indvars.iv8, !dbg !1031
  store float %conv, float* %arrayidx, align 4, !dbg !1032
  %3 = trunc i64 %indvars.iv8 to i32, !dbg !1033
  %conv3 = sitofp i32 %3 to float, !dbg !1033
  %mul = fmul contract float %conv3, 2.000000e+00, !dbg !1034
  %arrayidx5 = getelementptr inbounds float, float* %1, i64 %indvars.iv8, !dbg !1035
  store float %mul, float* %arrayidx5, align 4, !dbg !1036
  br label %for.inc, !dbg !1037

for.inc:                                          ; preds = %for.body
  %indvars.iv.next9 = add nuw nsw i64 %indvars.iv8, 1, !dbg !1038
  call void @llvm.dbg.value(metadata i32 undef, metadata !1022, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !1024
  br label %for.cond, !dbg !1039, !llvm.loop !1040

for.end:                                          ; preds = %for.cond
  %4 = bitcast i8* %call2 to float*, !dbg !1042
  call void @llvm.dbg.declare(metadata float** %d_a, metadata !1043, metadata !DIExpression()), !dbg !1044
  call void @llvm.dbg.declare(metadata float** %d_b, metadata !1045, metadata !DIExpression()), !dbg !1046
  call void @llvm.dbg.declare(metadata float** %d_c, metadata !1047, metadata !DIExpression()), !dbg !1048
  %5 = bitcast float** %d_a to i8**, !dbg !1049
  %call6 = call i32 @cudaMalloc(i8** %5, i64 40), !dbg !1050
  %6 = bitcast float** %d_b to i8**, !dbg !1051
  %call7 = call i32 @cudaMalloc(i8** %6, i64 40), !dbg !1052
  %7 = bitcast float** %d_c to i8**, !dbg !1053
  %call8 = call i32 @cudaMalloc(i8** %7, i64 40), !dbg !1054
  %8 = bitcast float* %0 to i8*, !dbg !1055
  %9 = bitcast float* %0 to i8*, !dbg !1056
  %call9 = call i32 @cudaMemcpy(i8* %8, i8* %9, i64 40, i32 1), !dbg !1057, !tulip.target.start.of.map !1058
  call void @llvm.dbg.value(metadata i32 256, metadata !1059, metadata !DIExpression()), !dbg !1016
  %call11 = call i32 @_ZL10num_blocksii(i32 10, i32 256), !dbg !1061
  call void @llvm.dbg.value(metadata i32 %call11, metadata !1062, metadata !DIExpression()), !dbg !1016
  %dim3gep.0 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 0
  store i32 %call11, i32* %dim3gep.0
  %dim3gep.1 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 1
  store i32 1, i32* %dim3gep.1
  %dim3gep.2 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp, i32 0, i32 2
  store i32 1, i32* %dim3gep.2
  %dim3gep.02 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 0
  store i32 256, i32* %dim3gep.02
  %dim3gep.13 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 1
  store i32 1, i32* %dim3gep.13
  %dim3gep.24 = getelementptr %struct.dim3, %struct.dim3* %agg.tmp12, i32 0, i32 2
  store i32 1, i32* %dim3gep.24
  %10 = bitcast { i64, i32 }* %agg.tmp.coerce to i8*, !dbg !1063
  %11 = bitcast %struct.dim3* %agg.tmp to i8*, !dbg !1063
  %12 = call i8* @memcpy(i8* %10, i8* %11, i64 12), !dbg !1063
  %13 = bitcast { i64, i32 }* %agg.tmp12.coerce to i8*, !dbg !1063
  %14 = bitcast %struct.dim3* %agg.tmp12 to i8*, !dbg !1063
  %15 = call i8* @memcpy(i8* %13, i8* %14, i64 12), !dbg !1063
  br label %header.0

header.0:                                         ; preds = %latch.0, %for.end
  %indvar.0 = phi i32 [ 0, %for.end ], [ %indvar.next.0, %latch.0 ]
  %exitcond7 = icmp ne i32 %indvar.0, %call11
  br i1 %exitcond7, label %header.1.preheader, label %kcall.end, !tulip.doall.loop.grid !1058

header.1.preheader:                               ; preds = %header.0
  br label %header.1

header.1:                                         ; preds = %header.1.preheader, %latch.1
  %indvar.1 = phi i32 [ %indvar.next.1, %latch.1 ], [ 0, %header.1.preheader ]
  %exitcond6 = icmp ne i32 %indvar.1, 256
  br i1 %exitcond6, label %kcall.configok, label %latch.0, !tulip.doall.loop.block !1058

latch.1:                                          ; preds = %kcall.configok
  %indvar.next.1 = add nuw nsw i32 %indvar.1, 1
  br label %header.1

latch.0:                                          ; preds = %header.1
  %indvar.next.0 = add i32 %indvar.0, 1
  br label %header.0

kcall.configok:                                   ; preds = %header.1
  call void @_Z10vector_addPfS_S_i.1(float* %0, float* %1, float* %4, i32 10, i32 %call11, i32 1, i32 1, i32 256, i32 1, i32 1, i32 %indvar.0, i32 0, i32 0, i32 %indvar.1, i32 0, i32 0)
  br label %latch.1

kcall.end:                                        ; preds = %header.0
  %16 = bitcast float* %4 to i8*, !dbg !1064
  %17 = bitcast float* %4 to i8*, !dbg !1065
  %call14 = call i32 @cudaMemcpy(i8* %16, i8* %17, i64 40, i32 2), !dbg !1066, !tulip.target.end.of.map !1058
  call void @llvm.dbg.value(metadata i32 0, metadata !1067, metadata !DIExpression()), !dbg !1069
  br label %for.cond19, !dbg !1070

for.cond19:                                       ; preds = %for.inc32, %kcall.end
  %indvars.iv = phi i64 [ %indvars.iv.next, %for.inc32 ], [ 0, %kcall.end ], !dbg !1069
  call void @llvm.dbg.value(metadata i64 %indvars.iv, metadata !1067, metadata !DIExpression()), !dbg !1069
  %exitcond = icmp ne i64 %indvars.iv, 10, !dbg !1071
  br i1 %exitcond, label %for.body21, label %for.end34, !dbg !1073

for.body21:                                       ; preds = %for.cond19
  %arrayidx23 = getelementptr inbounds float, float* %0, i64 %indvars.iv, !dbg !1074
  %18 = load float, float* %arrayidx23, align 4, !dbg !1074
  %conv24 = fpext float %18 to double, !dbg !1074
  %arrayidx26 = getelementptr inbounds float, float* %1, i64 %indvars.iv, !dbg !1076
  %19 = load float, float* %arrayidx26, align 4, !dbg !1076
  %conv27 = fpext float %19 to double, !dbg !1076
  %arrayidx29 = getelementptr inbounds float, float* %4, i64 %indvars.iv, !dbg !1077
  %20 = load float, float* %arrayidx29, align 4, !dbg !1077
  %conv30 = fpext float %20 to double, !dbg !1077
  %call31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str, i64 0, i64 0), double %conv24, double %conv27, double %conv30), !dbg !1078
  br label %for.inc32, !dbg !1079

for.inc32:                                        ; preds = %for.body21
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1, !dbg !1080
  call void @llvm.dbg.value(metadata i32 undef, metadata !1067, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !1069
  br label %for.cond19, !dbg !1081, !llvm.loop !1082

for.end34:                                        ; preds = %for.cond19
  %21 = bitcast float* %0 to i8*, !dbg !1084
  call void @free(i8* %21) #8, !dbg !1085
  %22 = bitcast float* %1 to i8*, !dbg !1086
  call void @free(i8* %22) #8, !dbg !1087
  %23 = bitcast float* %4 to i8*, !dbg !1088
  call void @free(i8* %23) #8, !dbg !1089
  ret i32 0, !dbg !1090
}

SUSAN: getting value name for: 
declare dso_local i32 @cudaMalloc(i8**, i64) #4

SUSAN: getting value name for: 
declare dso_local i32 @cudaMemcpy(i8*, i8*, i64, i32) #4

SUSAN: getting value name for: 
; Function Attrs: noinline nounwind uwtable
define internal i32 @_ZL10num_blocksii(i32 %num, i32 %factor) #5 !dbg !1091 {
entry:
  call void @llvm.dbg.value(metadata i32 %num, metadata !1094, metadata !DIExpression()), !dbg !1095
  call void @llvm.dbg.value(metadata i32 %factor, metadata !1096, metadata !DIExpression()), !dbg !1095
  %add = add nsw i32 %num, %factor, !dbg !1097
  %sub = sub nsw i32 %add, 1, !dbg !1098
  %div = sdiv i32 %sub, %factor, !dbg !1099
  ret i32 %div, !dbg !1100
}

SUSAN: getting value name for: 
declare dso_local i32 @cudaConfigureCall(i64, i32, i64, i32, i64, %struct.CUstream_st*) #4

SUSAN: getting value name for: 
declare dso_local i32 @cudaFree(i8*) #4

SUSAN: getting value name for: 
; Function Attrs: convergent noinline nounwind
define dso_local void @_Z10vector_addPfS_S_i.1(float* %a, float* %b, float* %c, i32 %n, i32 %gridDim.x, i32 %gridDim.y, i32 %gridDim.z, i32 %blockDim.x, i32 %blockDim.y, i32 %blockDim.z, i32 %blockIdx.x, i32 %blockIdx.y, i32 %blockIdx.z, i32 %threadIdx.x, i32 %threadIdx.y, i32 %threadIdx.z) #7 {
entry:
  call void @llvm.dbg.value(metadata float* %a, metadata !1101, metadata !DIExpression()), !dbg !1105
  call void @llvm.dbg.value(metadata float* %b, metadata !1106, metadata !DIExpression()), !dbg !1105
  call void @llvm.dbg.value(metadata float* %c, metadata !1107, metadata !DIExpression()), !dbg !1105
  call void @llvm.dbg.value(metadata i32 %n, metadata !1108, metadata !DIExpression()), !dbg !1105
  call void @llvm.dbg.value(metadata i32 %threadIdx.x, metadata !1109, metadata !DIExpression()), !dbg !1105
  %cmp = icmp slt i32 %threadIdx.x, %n, !dbg !1110
  br i1 %cmp, label %if.then, label %if.end, !dbg !1112

if.then:                                          ; preds = %entry
  %idxprom = sext i32 %threadIdx.x to i64, !dbg !1113
  %arrayidx = getelementptr inbounds float, float* %a, i64 %idxprom, !dbg !1113
  %0 = load float, float* %arrayidx, align 4, !dbg !1113
  %idxprom1 = sext i32 %threadIdx.x to i64, !dbg !1114
  %arrayidx2 = getelementptr inbounds float, float* %b, i64 %idxprom1, !dbg !1114
  %1 = load float, float* %arrayidx2, align 4, !dbg !1114
  %add = fadd contract float %0, %1, !dbg !1115
  %idxprom3 = sext i32 %threadIdx.x to i64, !dbg !1116
  %arrayidx4 = getelementptr inbounds float, float* %c, i64 %idxprom3, !dbg !1116
  store float %add, float* %arrayidx4, align 4, !dbg !1117
  br label %if.end, !dbg !1116

if.end:                                           ; preds = %if.then, %entry
  ret void, !dbg !1118
}

SUSAN: currGlob: @.str = private unnamed_addr constant [20 x i8] c"%.1f + %.1f = %.1f\0A\00", align 1
SUSAN: getting value name for: @.str = private unnamed_addr constant [20 x i8] c"%.1f + %.1f = %.1f\0A\00", align 1
CBackend: writeOperand 3595: [20 x i8] c"%.1f + %.1f = %.1f\0A\00"
CBackend: writeoperand here 3674? 
